计算机操作系统笔记

当相互合作的进程(线程)处于同一计算机系统时，通常在它们之间是采用直接通信方
式，即由源进程利用发送命令直接将消息(Message)挂到目标进程的消息队列上，以后由目
标进程利用接收命令从其消息队列中取出消息。


CPU 运行的高速性和I/O 低速性间的矛盾自计算机诞生时起便已存在了。

系统吞吐量是指系统在单位时间内所完成的总工作量

分层结构的主要缺点是：系统效率降低了。由于层次结构是分层单向依赖的，因此必
须在相邻层之间都要建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越
多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。

在未配置OS的系统中，程序的执行方式是顺序执行，即必须在一个程序执行完后，才
允许另一个程序执行；在多道程序环境下，则允许多个程序并发执行。程序的这两种执行
方式间有着显著的不同。也正是程序并发执行时的这种特征，才导致了在操作系统中引入
进程的概念。

通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制
块，即PCB(Process Control Block)；而由程序段、相关的数据段和PCB三部分便构成了进
程实体
OS是根据PCB来对并发执行的进程进行控制和管理的。例如，当OS要调度某进程执行时，要从该进程的PCB
中查出其现行状态及优先级；在调度到某进程后，要根据其PCB 中所保存的处理机状态信
息，设置该进程恢复运行的现场，并根据其PCB 中的程序和数据的内存始址，找到其程序
和数据；

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

运行中的进程可能具有以下三种基本状态。
1) 就绪(Ready)状态
当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进
程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们
排成一个队列，称为就绪队列。
2) 执行状态
进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；
在多处理机系统中，则有多个进程处于执行状态。
3) 阻塞状态
正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，
亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。
致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也
排成一个队列

子进程可以继承父进程所拥有的资源，例
如，继承父进程打开的文件，继承父进程所分配到的缓冲区等。当子进程被撤消时，应将
其从父进程那里获得的资源归还给父进程。


高级通信机制可归结为三大类：
共享存储器系统、消息传递系统以及管道通信系统。

1．共享存储器系统
公用数据结构的设置及对进程间同步的处理，都是程序员的职
责。这无疑增加了程序员的负担，而操作系统却只须提供共享存储器。因此，这种通信方
式是低效的，只适于传递相对少量的数据。

2．消息传递系统
消息传递系统(Message passing system)是当前应用最为广泛的一种进程间的通信机制。
在该机制中，进程间的数据交换是以格式化的消息(message)为单位的；在计算机网络中，
又把message称为报文。程序员直接利用操作系统提供的一组通信命令(原语)，不仅能实现
大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的，从而大大
减化了通信程序编制的复杂性，因而获得了广泛的应用。

3．管道通信
所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享
文件，又名pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将
大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。
由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于
UNIX 系统，由于它能有效地传送大量数据，因而又被引入到许多其它的操作系统中。

换言之，由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之
付出较大的时空开销。正因如此，在系统中所设置的进程，其数目不宜过多，进程切换的
频率也不宜过高，这也就限制了并发程度的进一步提高。

一般而言，线程自己不拥有系统资源(也有一点必不可少的资
源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，
如已打开的文件、I/O 设备等，可以供该进程中的所有线程所共享。

在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程
中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线
程利用。
虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程
重新恢复运行。


由于网络使用的是bit 为单位，因此网络常使用的单位为Mbps 是Mbits per second，亦即是每秒多少Mbit。举例来说，大家常听到的20M/5M 光世代传输速度，如果转成文件容量的byte 时，其实理论最大传输值为：每秒2.5Mbyte/ 每秒625Kbyte的下载/上传速度

一般硬盘制造商会使用十进制的单位，所以500GByte代表为500*1000*1000*1000Byte之意。转成文件的容量单位时使用二进制(1024为底)，所以就成为466GB左右的容量了。


字组大小依据CPU的设计而有32位与64位。我们现在所称的计算机是32或64位主要是依据这个CPU解析的字组大小而来的！早期的32位CPU中，因为CPU每次能够解析的数据量有限，因此由主存储器传来的数据量就有所限制了。这也导致32位的CPU最多只能支持最大到4GBytes的内存

还记得你的计算机在开机的时候可以按下[Del]按键来进入一个名为BIOS的画面吧？BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)。ROM是一种非挥发性的内存。另外，BIOS对于个人计算机来说是非常重要的，因为他是系统在开机的时候首先会去读取的一个小程序


例题：假设你的桌面使用1024x768分辨率，且使用全彩(每个像素占用3bytes的容量)，请问你的显示适配器至少需要多少内存才能使用这样的彩度？

答：因为1024x768分辨率中会有786432个像素，每个像素占用3bytes，所以总共需要2.25MBytes以上才行！但如果考虑屏幕的更新率(每秒钟屏幕的更新次数)，显示适配器的内存还是越大越好！

透过的数据算法的关系，当传输10 位编码时，仅有8 位为数据，其余2 位为检验之用。因此带宽的计算上面，使用的换算(bit 转byte) 为1:10 而不是1byte=8bits


1.机器语言        0101的二进制语言
优点：计算机硬件可以直接识别执行，执行速度快
缺点：  很难开发，开发效率低

2.汇编语言        用英文标签取代二进制指令，本质还是在直接操作硬件
优点：比机器语言开发效率高点（但是对现在的人程序员而言开发的难度还是很大）
缺点：执行速度没机器语言快

3.高级语言        就是直接人能理解的语言语法风格来编写程序，程序员无需要在去考虑复杂的硬件操作
需要把程序编程成二级制指令，计算机才执行程序
按照编译的方式的不同，高级语又分为两大类：
1.编译型：程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，
以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件）
前期需要写好大量的代码，在通过编制后执行
优点：执行效率比解释型快
缺点：开发效率不如解释型
2.解释型：解释性语言的程序不需要编译
解释性语言在运行程序的时候才翻译二级制指令 
专门有一个解释器能够直接执行程序，每个语句都是执行的时候才翻译。
这样解释性语言每执行一次就要翻译一次，执行效率比较低
主要用于测试语法是否报错
这样就可以有利于加快开发效率
优点：开发效率比编译型高
缺点：执行效率比编译型慢

Unix是以较高阶的C语言写的，相对于汇编语言需要与硬件有密切的配合，高阶的C语言与硬件的相关性就没有这么大了

配置 OS后可使计算机系统更容易使用。一个未配置OS的计算机系统是极难使用的，因为计算机硬件只能识别0 和1 这样的机器代码。用户要直接在计算机硬件上运行自己所编写的程序，就必须用机器语言书写程序；用户要想输入数据或打印数据，也都必须自己用机器语言书写相应的输入程序或打印程序。如果我们在计算机硬件上配置了OS，用户便可通过OS所提供的各种命令来使用计算机系统。比如，用编译命令可方便地把用户用高级语言书写的程序翻译成机器代码，大大地方便了用户，从而使计算机变得易学易用。

在未配置OS 的计算机系统中，诸如CPU、I/O 设备等各种资源，都会因它们经常处于空闲状态而得不到充分利用；内存及外存中所存放的数据太少或者无序而浪费了大量的存储空间。配置了OS 之后，可使CPU 和I/O 设备由于能保持忙碌状态而得到有效的利用，且可使内存和外存中存放的数据因有序而节省了存储空间。

可以从不同的观点(角度)来观察OS 的作用。从一般用户的观点，可把OS 看做是用户与计算机硬件系统之间的接口；从资源管理的观点看，则可把OS视为计算机系统资源的管理者。另外，OS实现了对计算机资源的抽象，隐藏了对硬件操作的细节，使用户能更方便地使用机器。

用户可通过以下三种方式使用计算机。

(1) 命令方式。这是指由OS提供了一组联机命令接口，以允许用户通过键盘输入有关命令来取得操作系统的服务，并控制用户程序的运行。

(2) 系统调用方式。OS提供了一组系统调用，用户可在自己的应用程序中通过相应的系统调用，来实现与操作系统的通信，并取得它的服务。

(3) 图形、窗口方式。这是当前使用最为方便、最为广泛的接口，它允许用户通过屏幕上的窗口和图标来实现与操作系统的通信，并取得它的服务。

在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：处理器、存储器、I/O 设备以及信息(数据和程序)。相应地，OS的主要功能也正是针对这四类资源进行有效的管理，即：处理机管理，用于分配和控制处理机；存储器管理，主要负责内存的分配与回收； I/O 设备管理，负责I/O 设备的分配与操纵；文件管理，负责文件的存取、共享和保护。可见，OS的确是计算机系统资源的管理者。事实上，当今世界上广为流行的一个关于OS作用的观点，正是把OS作为计算机系统的资源管理者。

OS是铺设在计算机硬件上的多层系统软件，它们不仅增强了系统的功能，而且还隐藏了对硬件操作的细节，由它们实现了对计算机硬件操作的多个层次的抽象。值得说明的是，对一个硬件在底层进行抽象后，在高层还可再次对该资源进行抽象，成为更高层的抽象模型。随着抽象层次的提高，抽象接口所提供的功能就越来越强，用户使用起来也更加方便。

并行性和并发性(Concurrence)是既相似又有区别的两个概念，并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可同时执行。

应当指出，通常的程序是静态实体(Passive Entity)，在多道程序系统中，它们是不能独立运行的，更不能和其它程序并发执行。在操作系统中引入进程的目的，就是为了使多个程序能并发执行。例如，在一个未引入进程的系统中，在属于同一个应用程序的计算程序和I/O 程序之间，两者只能是顺序执行，即只有在计算程序执行告一段落后，才允许I/O 程序执行；反之，在程序执行I/O 操作时，计算程序也不能执行，这意味着处理机处于空闲状态。但在引入进程后，若分别为计算程序和I/O 程序各建立一个进程，则这两个进程便可并发执行。由于在系统中具备使计算程序和I/O 程序同时运行的硬件条件，因而可将系统中的CPU 和I/O 设备同时开动起来，实现并行工作，从而有效地提高了系统资源的利用率和系统吞吐量，并改善了系统的性能。引入进程的好处远不止于此，事实上可以在内存中存放多个用户程序，分别为它们建立进程后，这些进程可以并发执行，亦即实现前面所说的多道程序运行。这样便能极大地提高系统资源的利用率，增加系统的吞吐量。为使多个程序能并发执行，系统必须分别为每个程序建立进程(Process)。简单说来，进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。一个进程在运行时需要一定的资源，如CPU、存储空间及I/O 设备等。OS中程序的并发执行将使系统复杂化，以致在系统中必须增设若干新的功能模块，分别用于对处理机、内存、I/O 设备以及文件系统等资源进行管理，并控制系统中作业的运行。事实上，进程和并发是现代操作系统中最重要的基本概念，也是操作系统运行的基础

长期以来，进程都是操作系统中可以拥有资源并作为独立运行的基本单位。当一个进程因故不能继续运行时，操作系统便调度另一进程运行。由于进程拥有自己的资源，故使调度付出的开销较大。直到20 世纪80 年代中期，人们才又提出了比进程更小的单位——线程(Threads)。

通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的OS中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效地提高系统内多个程序间并发执行的程度。因而近年来推出的通用操作系统都引入了线程，以便进一步提高系统的并发性，并把它视作现代操作系统的一个重要标致。

内存中的每个进程在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需多少时间才能完成，等等，这些都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要I/O，而有的程序其计算少而I/O 多，这样，很可能是先进入内存的作业后完成，而后进入内存的作业先完成。或者说，进程是以人们不可预知的速度向前推进，此即进程的异步性(Asynchronism)。尽管如此，但只要在操作系统中配置有完善的进程同步机制，且运行环境相同，作业经多次运行都会获得完全相同的结果。因此，异步运行方式是允许的，而且是操作系统的一个重要特征。

当相互合作的进程(线程)处于同一计算机系统时，通常在它们之间是采用直接通信方式，即由源进程利用发送命令直接将消息(Message)挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。

CPU 运行的高速性和I/O 低速性间的矛盾自计算机诞生时起便已存在了。而随着CPU速度迅速提高，使得此矛盾更为突出，严重降低了CPU的利用率。如果在I/O 设备和CPU之间引入缓冲，则可有效地缓和CPU与I/O 设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量。因此，在现代计算机系统中，都无一例外地在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法来改善系统的性能。

为了方便用户使用操作系统，OS 又向用户提供了“用户与操作系统的接口”。该接口通常可分为两大类：

(1) 用户接口。它是提供给用户使用的接口，用户可通过该接口取得操作系统的服务；(控制台命令、图形化接口)

(2) 程序接口。它是提供给程序员在编程时使用的接口，是用户程序取得操作系统服务

该接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的惟一途径。它是由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用；但在高级语言以及C 语言中，往往提供了与各系统调用一一对应的库函数，这样，应用程序便可通过调用对应的库函数来使用系统调用。但在近几年所推出的操作系统中，如UNIX、OS/2 版本中，其系统调用本身已经采用C语言编写，并以函数形式提供，故在用C语言编制的程序中，可直接使用系统调用。

分层结构的优缺点

分层结构的主要优点有：

(1) 易保证系统的正确性。自下而上的设计方式，使所有设计中的决定都是有序的，或者说是建立在较为可靠的基础上的，这样比较容易保证整个系统的正确性。

(2) 易扩充和易维护性。在系统中增加、修改或替换一个层次中的模块或整个层次，只要不改变相应层次间的接口，就不会影响其它层次，这必将使系统维护和扩充变得更加容易。

分层结构的主要缺点是：系统效率降低了。由于层次结构是分层单向依赖的，因此必须在相邻层之间都要建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。

子进程可以继承父进程所拥有的资源，例如，继承父进程打开的文件，继承父进程所分配到的缓冲区等。当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。此外，在撤消父进程时，也必须同时撤消其所有的子进程。

在多道程序环境中，只有(作为)进程(时)才能在系统中运行。因此，为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的典型事件，可有以下四类：

(1) 用户登录。在分时系统中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入就绪队列中。

(2) 作业调度。在批处理系统中，当作业调度程序按一定的算法调度到某作业时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入就绪队列中。

(3) 提供服务。当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务，例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样，不仅可使打印进程与该用户进程并发执行，而且还便于计算出为完成打印任务所花费的时间。

(4) 应用请求。在上述三种情况下，都是由系统内核为它创建一个新进程；而第4 类事件则是基于应用进程的需求，由它自己创建一个新进程，以便使新进程以并发运行方式完成特定任务。

引起进程终止的事件

1) 正常结束

在任何计算机系统中，都应有一个用于表示进程已经运行完成的指示。例如，在批处理系统中，通常在程序的最后安排一条Holt指令或终止的系统调用。当程序运行到Holt指令时，将产生一个中断，去通知OS本进程已经完成。在分时系统中，用户可利用Logs off去表示进程运行完毕，此时同样可产生一个中断，去通知OS进程已运行完毕。

2) 异常结束

在进程运行期间，由于出现某些错误和故障而迫使进程终止(Termination of Process)。

这类异常事件很多，常见的有下述几种：

(1) 越界错误。这是指程序所访问的存储区已越出该进程的区域。

(2) 保护错。这是指进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件。

(3) 非法指令。这是指程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令。

(4) 特权指令错。这是指用户进程试图去执行一条只允许OS执行的指令。

(5) 运行超时。这是指进程的执行时间超过了指定的最大值。

(6) 等待超时。这是指进程等待某事件的时间超过了规定的最大值。

(7) 算术运算错。这是指进程试图去执行一个被禁止的运算，例如被0 除。

(8) I/O 故障。这是指在I/O 过程中发生了错误等。

3) 外界干预

外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。这些干预有：

(1) 操作员或操作系统干预。由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程。

(2) 父进程请求。由于父进程具有终止自己的任何子孙进程的权力，因而当父进程提出请求时，系统将终止该进程。

(3) 父进程终止。当父进程终止时，OS也将它的所有子孙进程终止。

进程通信，是指进程之间的信息交换，其所交换的信息量少者是一个状态或数值，多者则是成千上万个字节。进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。在进程互斥中，进程通过只修改信号量来向其他进程表明临界资源是否可用。在生产者—消费者问题中，生产者通过缓冲池将所生产的产品传送给消费者。应当指出，信号量机制作为同步工具是卓有成效的，但作为通信工具，则不够理想。

随着OS的发展，用于进程之间实现通信的机制也在发展，并已由早期的低级进程通信机制发展为能传送大量数据的高级通信工具机制。目前，高级通信机制可归结为三大类：共享存储器系统、消息传递系统以及管道通信系统。

管道通信

所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于UNIX 系统，由于它能有效地传送大量数据，因而又被引入到许多其它的操作系统中。

为了协调双方的通信，管道机制必须提供以下三方面的协调能力：

(1) 互斥，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待。

(2) 同步，指当写(输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。

(3) 确定对方是否存在，只有确定了对方已存在时，才能进行通信。

线程的引入

如果说，在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。为了说明这一点，我们首先来回顾进程的两个基本属性: ① 进程是一个可拥有资源的独立单位；② 进程同时又是一个可独立调度和分派的基本单位。正是由于进程有这两个基本属性，才使之成为一个能独立运行的基本单位，从而也就构成了进程并发执行的基础。然而，为使程序能并发执行，系统还必须进行以下的一系列操作。

1) 创建进程

系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O 设备，以及建立相应的PCB。

2) 撤消进程

系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB。

3) 进程切换

对进程进行切换时，由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，因而须花费不少的处理机时间。

换言之，由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之付出较大的时空开销。正因如此，在系统中所设置的进程，其数目不宜过多，进程切换的频率也不宜过高，这也就限制了并发程度的进一步提高。如何能使多个程序更好地并发执行同时又尽量减少系统的开销，已成为近年来设计操作系统时所追求的重要目标。有不少研究操作系统的学者们想到，若能将进程的上述两个属性分开，由操作系统分开处理，亦即对于作为调度和分派的基本单位，不同时作为拥有资源的单位，以做到“轻装上阵”；而对于拥有资源的基本单位，又不对之进行频繁的切换。正是在这种思想的指导下，形成了线程的概念。

不论是传统的操作系统，还是引入了线程的操作系统，进程都可以拥有资源，是系统中拥有资源的一个基本单位。一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O 设备等，可以供该进程中的所有线程所共享。线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证其独立运行的资源，比如，在每个线程中都应具有一个用于控制线程运行的线程控制块TCB，用于指示被执行指令序列的程序计数器，保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。

在多线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。它可根据需要再去创建若干个线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。

如同进程一样，线程也是具有生命期的。终止线程的方式有两种：一种是在线程完成了自己的工作后自愿退出；另一种是线程在运行中出现错误或由于某种原因而被其它线程强行终止。但有些线程(主要是系统线程)，在它们一旦被建立起来之后，便一直运行下去而不再被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。

虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。

多线程OS中的进程

在多线程OS中，进程是作为拥有系统资源的基本单位，通常的进程都包含多个线程并为它们提供资源，但此时的进程就不再作为一个执行的实体。多线程OS 中的进程有以下属性：

(1) 作为系统资源分配的单位。在多线程OS中，仍是将进程作为系统资源分配的基本单位，在任一进程中所拥有的资源包括受到分别保护的用户地址空间、用于实现进程间和线程间同步和通信的机制、已打开的文件和已申请到的I/O 设备，以及一张由核心进程维护的地址映射表，该表用于实现用户程序的逻辑地址到其内存物理地址的映射。

(2) 可包括多个线程。通常，一个进程都含有多个相对独立的线程，其数目可多可少，但至少也要有一个线程，由进程为这些(个)线程提供资源及运行环境，使这些线程可并发执行。在OS中的所有线程都只能属于某一个特定进程。

(3) 进程不是一个可执行的实体。在多线程OS中，是把线程作为独立运行的基本单位，所以此时的进程已不再是一个可执行的实体。虽然如此，进程仍具有与执行相关的状态。例如，所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。此外，对进程所施加的与进程状态有关的操作，也对其线程起作用。例如，在把某个进程挂起时，该进程中的所有线程也都将被挂起；又如，在把某进程激活时，属于该进程的所有线程也都将被激活。

高速缓存

高速缓存是现代计算机结构中的一个重要部件，其容量大于或远大于寄存器，而比内存约小两到三个数量级左右，从几十KB到几MB，访问速度快于主存储器。根据程序执行的局部性原理(即程序在执行时将呈现出局部性规律，在一较短的时间内，程序的执行仅局限于某个部分)，将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度。通常，进程的程序和数据是存放在主存储器中，每当使用时，被临时复制到一个速度较快的高速缓存中。当CPU访问一组特定信息时，首先检查它是否在高速缓存中，如果已存在，可直接从中取出使用，以避免访问主存，否则，再从主存中读出信息。如大多数计算机有指令高速缓存，用来暂存下一条欲执行的指令，如果没有指令高速缓存，CPU 将会空等若干个周期，直到下一条指令从主存中取出。由于高速缓存的速度越高价格也越贵，故有的计算机系统中设置了两级或多级高速缓存。紧靠内存的一级高速缓存的速度最高，而容量最小，二级高速缓存的容量稍大，速度也稍低。

磁盘缓存

由于目前磁盘的I/O 速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器存储空间的扩充，即利用主存中的存储空间，来暂存从磁盘中读出(或写入)的信息。主存也可以看做是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用；反之，数据也必须先存在主存中，才能输出到辅存。

一个文件的数据可能出现在存储器层次的不同级别中，例如，一个文件数据通常被存储在辅存中(如硬盘)，当其需要运行或被访问时，就必须调入主存，也可以暂时存放在主存的磁盘高速缓存中。大容量的辅存常常使用磁盘，磁盘数据经常备份到磁带或可移动磁盘组上，以防止硬盘故障时丢失数据。有些系统自动地把老文件数据从辅存转储到海量存储器中，如磁带上，这样做还能降低存储价格。

局部性原理

早在1968 年，Denning.P 就曾指出：程序在执行时将呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。他提出了下述几个论点：

(1) 程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。该论点也在后来的许多学者对高级程序设计语言(如FORTRAN 语言、PASCAL 语言)及C语言规律的研究中被证实。

(2) 过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域，但经研究看出，过程调用的深度在大多数情况下都不超过5。这就是说，程序将会在一段时间内都局限在这些过程的范围内运行。

(3) 程序中存在许多循环结构，这些虽然只由少数指令构成，但是它们将多次执行。

(4) 程序中还包括许多对数据结构的处理，如对数组进行操作，它们往往都局限于很小的范围内。

局限性还表现在下述两个方面：

(1) 时间局限性。如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。

(2) 空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。

基于局部性原理，应用程序在运行之前，没有必要全部装入内存，仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。程序在运行时，如果它所要访问的页(段)已调入内存，便可继续执行下去；但如果程序所要访问的页(段)尚未调入内存(称为缺页或缺段)，此时程序应利用OS所提供的请求调页(段)功能，将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页(段)，则还须再利用页(段)的置换功能，将内存中暂时不用的页(段)调至盘上，腾出足够的内存空间后，再将要访问的页(段)调入内存，使程序继续执行下去。这样，便可使一个大的用户程序能在较小的内存空间中运行；也可在内存中同时装入更多的进程使它们并发执行。从用户角度看，该系统所具有的内存容量，将比实际内存容量大得多。但须说明，用户所看到的大容量只是一种感觉，是虚的，故人们把这样的存储器称为虚拟存储器。

磁盘是可供多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳调度算法，以使各进程对磁盘的平均访问时间最小。由于在访问磁盘的时间中，主要是寻道时间，因此，磁盘调度的目标是使磁盘的平均寻道时间最少。目前常用的磁盘调度算法有先来先服务、最短寻道时间优先及扫描等算法。

在所有的OS中，都是把命令解释程序放在OS的最高层，以便能直接与用户交互。该程序的主要功能是先对用户输入的命令进行解释，然后转入相应命令的处理程序去执行。在MS-DOS中的命令解释程序是COMMAND.COM，在UNIX 中是Shell。

UNIX 的Shell 是作为操作系统的最外层，也称为外壳。它可以作为命令语言，为用户提供使用操作系统的接口，用户利用该接口与机器交互。Shell 也是一种程序设计语言，用户可利用多条Shell 命令构成一个文件，或称为Shell 过程。Shell 还包括了Shell 命令解释程序，用于对从标准输入或文件中读入的命令进行解释执行。

在计算机系统中，通常运行着两类程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态：系统态(也称为管态或核心态)和用户态(也称为目态)。操作系统在系统态运行，而应用程序只能在用户态运行。在实际运行过程中，处理机会在系统态和用户态间切换。相应地，现代多数操作系统将CPU的指令集分为特权指令和非特权指令两类。

1) 特权指令

所谓特权指令，就是在系统态时运行的指令，是关系到系统全局的指令。其对内存空间的访问范围基本不受限制，不仅能访问用户存储空间，也能访问系统存储空间，如启动各种外部设备、设置系统时钟时间、关中断、清主存、修改存储器管理寄存器、执行停机指令、转换执行状态等。特权指令只允许操作系统使用，不允许应用程序使用，否则会引起系统混乱。

2) 非特权指令

非特权指令是在用户态时运行的指令。一般应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，其对内存的访问范围也局限于用户空间。这样，可以防止应用程序的运行异常对系统造成的破坏。这种限制是由硬件实现的，如果在应用程序中使用了特权指令，就会发出权限出错信号，操作系统捕获到这个信号后，将转入相应的错误处理程序，并将停止该应用程序的运行，重新调度。

1) 传输控制协议TCP

针对IP协议是提供面向无连接的、不可靠的数据报服务，TCP则提供了面向连接的、可靠的端—端通信机制。所谓面向连接，是指在端系统要传送数据前，应先进行端—端之间的连接；在数据传送完后，应拆除连接。而所谓可靠是指，即使网络层(通信子网)出现了差错，TCP协议仍能正确地控制连接的建立、数据的传输和连接的释放。为了确保数据传输的可靠性，在TCP 中采用了确认和重发措施，即接收方每收到一个正确的数据段时，都应根据数据段中的发送序号，给发送方回送一个用于确认的ACK 段。如果所接收的数据有错，则要求对方重发。此外，在进行正常的数据交换时，也要有流量控制，即控制发方发送数据段的速度不应超过接收方接收数据的能力。而对于紧急的数据段，则不应受流量控制。

2) 用户数据报协议UDP

应当指出，虽然TCP 协议提供了可靠的数据传输服务，但它却降低了传输效率，这对于早期通信网络不太可靠，而要传输的数据服务又非常重要，TCP 协议是十分必要的；但如果所传输的数据并非很重要，仍采用TCP协议则会显得有些浪费，此时可考虑利用UDP协议来传输数据。该协议是一种无连接的、不可靠的协议。它不要求网络中的端系统在数据传送之前先建立端—端之间的连接；同样，在数据传送结束后，也不要拆除连接。在数据传送过程中，无需对传送的数据进行差错检测，也不必对丢失的数据进行重发等。换言之，它是以一种比较简单的方式来传送数据，因而有效地提高了传输速率，比较适合于对传送可靠性要求不太严格，或能自己进行错误检测的应用程序，如简单网络管理协议等。

当一个用户A进程要查询用户B所在主机的域名时，他可以按下述步骤进行：

(1) 客户首先向本地域名服务器发出查询请求包IP(netlab.cs.nakai.edu.cn)；

(2) 如果本地服务器不知道该域名，便向顶级域名服务器发出查询请求包IP(netlab.cs.hankai.edu.cn)；

(3) 顶级服务器通常不知道查询的域名，但它知道所有下属域名服务器的IP 地址(202.113.16.10)，因此，它便将所查询的第二级域名服务器的IP地址，返回给本地服务器；

(4) 本地服务器又向第二级域名服务器进行查询；

(5) 由于它仍不知道所查询的域名，于是它便将所查询的第三级域名服务器的IP 地址(202.113.27.1)返回给本地服务器；

(6) 本地服务器又向第三级域名服务器进行查询；

(7) 由于在第三级服务器中找到了所查询的域名，于是把该域名所对应的IP 地址(202.113.56.10)回送给本地服务器；

(8) 由本地服务器将客户所查询的域名对应的IP地址传送给客户机。

这是最基本的一种域名解析方法，可以获得任何域名的IP 地址，但很明显，这种方式的解析效率是低下的，顶级域名服务器很容易过载。如果顶级域名服务器发生故障，同样会引起整个网络的瘫痪。但只要在每个域名服务器中配置一个高速缓存，用来存放最近使用过的域名及对应的IP地址等信息，以后，当用户再要访问该域名服务器的IP地址时，该域名服务器便可从自己的高速缓存中取出(IP地址)，这样，就避免了对域名服务器的重复访问。为使在缓存中的数据不会“过时”，服务器应定期更新缓存中的数据。

fork 系统调用

在 UNIX 的内核中设置了一个0 进程，它是惟一一个在系统引导时被创建的进程。在系统初启时，由0 进程再创建1 进程，以后0进程变为对换进程，1进程成为系统中的始祖进程。UNIX 利用fork为每个终端创建一个子进程为用户服务，如等待用户登录、执行shell命令解释程序等。每个终端进程又可利用fork 来创建自己的子进程，如此下去可以形成一棵进程树。因此说，系统中除0进程外的所有进程都是用fork创建的。

信号机制的基本概念

信号机制主要是作为在同一用户的诸进程之间通信的简单工具。信号本身是一个1～19中的某个整数，用来代表某一种事先约定好的简单消息。每个进程在执行时，都要通过信号机制来检查是否有信号到达。若有信号到达，表示某进程已发生了某种异常事件，便立即中断正在执行的进程，转向由该信号(某整数)所指示的处理程序，去完成对所发生的事件(事先约定)的处理。处理完毕，再返回到此前的断点处继续执行。可见，信号机制是对硬中断的一种模拟，故在早期的UNIX 版本中又称其为软中断。信号机制与中断机制之间的相似之处表现为：信号和中断都同样采用异步通信方式，在检测出有信号或有中断请求时，两者都是暂停正在执行的程序而转去执行相应的处理程序，处理完后都再返回到原来的断点；再有就是两者对信号或中断都可加以屏蔽。信号与中断两机制之间的差异是：中断有优先级，而信号机制则没有，即所有的信号都是平等的；再者是信号处理程序是在用户态下运行的，而中断处理程序则是在核心态下运行；还有，中断响应是及时的，而对信号的响应通常都有较长的时间延迟。

发送信号

这是指由发送进程把信号送至指定目标进程的proc 结构中信号域的某一位上。如果目标进程正在一个可被中断的优先级上睡眠，核心便将目标进程唤醒，发送过程就此结束。一个进程可能在其信号域中有多个位被置位， 代表已有多种类型的信号到达， 但对于一类信号， 进程却只能记住其中的某一个。进程可利用系统调用kill 向另一进程或一组进程发送一个信号。

对信号的处理

当一个进程要进入或退出一个低优先级睡眠状态时，或一个进程即将从核心态返回到用户态时，核心都要检查该进程是否已收到信号。当进程处于核心态时，即使收到信号也不予理睬；仅当进程返回到用户态时，才处理信号。对信号的处理分三种情况进行：当func=1时，进程不做任何处理便返回；当func=0 时，进程自我终止；当其值为非0、非1 的整数时，系统从核心态转为用户态后，便转向相应信号的处理程序(因为该程序是用户程序，故应运行在用户态)，处理完后，再返回到用户程序的断点。

管道机制

所谓管道，是指能够连接一个写进程和一个读进程、并允许它们以生产者—消费者方式进行通信的一个共享文件，又称为pipe 文件。由写进程从管道的入端将数据写入管道，而读进程则从管道的出端读出数据。
