JVM

java技术体系：
java程序设计语言
jvm
java API类库
Class文件格式
第三方java类库

java程序设计语言，jvm，java API类库 三部分统称为JDK
java API类库中的java SE API子集 和 jvm统称为JRE

JDK1.1
JAR,JDBC,RMI,JavaBeans,内部类、反射

JDK1.2
JIT,Swing,Collections,HotSpot

JDK1.3
JNDI

JDK1.4
NIO,日志

JDK1.5
自动装箱、泛型、注解、枚举、可变参数、foreach循环、concurrent包

JDK6
锁与同步、垃圾收集、类加载优化

JDK7
G1收集器

JDK中最核心的代码（jvm以及native方法的实现）是使用C++和少量的C语言编写的

--程序计数器--（PC计数器）

程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储

在多线程中，就会存在线程上下文切换执行，为了线程切换后能恢复正确的执行位置，所以需要从程序计数器中获取该线程需要执行的字节码的偏移地址（简单来说，可以先理解为执行的代码行号，但实际并不是所看到的代码行号，后续学习了字节码指令即明白了）。程序计数器是具备线程隔离性，每个线程工作时都有属于自己的独立程序计数器。

如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是native方法，这个计数器值则为空。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域


--栈--
-Xss参数设定

每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

局部变量表存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址），其中long和double类型的数据会占用2个局部变量空间，其余的数据类型都只占用1个，局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError
当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常

本地方法栈与普通的栈类似，只不过本地方法栈是为虚拟机使用到的Native方法服务
有的虚拟机（HotSpot）直接就把本地方法栈与虚拟机栈合二为一

--Java堆--
最小值-Xms参数与最大值-Xmx参数

在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都要在这里分配内存
也被成为GC堆（“垃圾”堆）
可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可

--方法区--
-XX:PermSize和-XX:MaxPermSize

用于存储已被虚拟机加载的类信息、常量、静态变量、JIT的代码
方法区并不完全等同于永久代，因为只是HotSpot使用永久代来实现方法区而已，其他虚拟机不存在永久代的概念

方法区可以选择不实现垃圾收集，相对而言，垃圾收集行为在这个区域是比较少出现的，但不是不进行GC，该区域主要是对常量池的回收和对类型的卸载

因为和堆的垃圾回收效率相比，方法区的回收效率实在太低，但是此部分内存区域也是可以被回收的。
一、当一个常量对象不再任何地方被引用的时候，则被标记为废弃常量，这个常量可以被回收。
二、方法区中的类需要同时满足以下三个条件才能被标记为无用的类：
1.Java堆中不存在该类的任何实例对象；
2.加载该类的类加载器已经被回收；
3.该类对应的java.lang.Class对象不在任何地方被引用，且无法在任何地方通过反射访问该类的方法。
当满足上述三个条件的类才可以被回收，但是并不是一定会被回收，需要参数进行控制，例如HotSpot虚拟机提供了-Xnoclassgc参数进行控制是否回收


--运行时常量池--

是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中

JVM对Class文件的每一个部分（包括Class常量池）的格式都有严格的规定，但对于运行时常量池，却没有做任何细节的要求
运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，不要求一定只能在编译期产生，也就是说并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，例如String类的intern()方法，该方法的作用是：如果池中已经包含一个等于此String对象的字符串，则返回此对象的引用，否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用

--直接内存--

并不是虚拟机运行时数据区的一部分
例如NIO，可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据
JVM Direct Memory
JVM除了堆内存、栈内存，还有DirectMemory内存，DirectMemory是java nio引入的。

在JDK1.4中新加入了NIO（New INput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，

然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了在Java堆和Native堆中来回复制数据。

Direct Memory是受GC控制的，例如ByteBuffer bb = ByteBuffer.allocateDirect(1024)，这段代码的执行会在堆外占用1k的内存，Java堆内只会占用一个对象的指针引用的大小，堆外的这1k的空间只有当bb对象被回收时，才会被回收，这里会发现一个明显的不对称现象，就是堆外可能占用了很多，而堆内没占用多少，导致还没触发GC，那就很容易出现Direct Memory造成物理内存耗光。

垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后顺便棒它清理内存的废弃对象。否则它只能一直等到抛出内存异常时，先catch掉，再在catch块里System.gc()。

--对象访问--

即使最普通的对象访问也会涉及栈、堆和方法区三个最重要内存区域之间的关联关系
Object obj = new Object();
"Object obj"这部分语义将会反映到java栈的本地变量表中，作为一个reference类型数据出现
"new Object()"这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存。
另外，在Java堆中还必须包含能查找到此对象类型数据（对象类型、父类、接口等）的地址信息，这些类型数据实际上存储在方法区中

由于reference类型在java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位实际的对象，因此不同的虚拟机实现的方式不同，主流的有两种：使用句柄和直接指针

	如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了堆中对象实例数据和方法区中的类型数据各自的具体地址信息

	如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是堆中的实际对象地址，对象中存储了方法区对象类型数据的地址

使用句柄最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改
使用直接指针好处是速度更快，节省了一次指针定位的时间开销，HotSpot是使用的此种方式
但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见

--OOM--	

将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展，避免每次垃圾回收完成后JVM重新分配内存
-Xmn 设置新生代大小 此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

堆内存的OOM是最常见的OOM，出现堆内存OOM时，异常堆栈信息"java.lang.OutOfMemoryError"会跟着进一步提示"Java heap space"
解决手段通常是对dump出来的文件进行分析，分清楚是出现内存泄漏还是内存溢出，如果是内存泄漏，进一步通过工具查看泄漏对象到GC Roots的引用链，定位出泄漏代码的位置
如果是正常的内存溢出，则调大堆内存大小
栈容量只由-Xss参数设定
如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说大多数情况下）达到1000~2000完全没有问题。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程，如果没有这方面的经验，这种通过减少内存的手段来解决内存溢出的方式会比较难以想到


JVM的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个FILO结构，需要频繁压栈出栈）。另外，由于栈是在内存实现的，而寄存器是在CPU的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲

java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出去


GC
程序计数器、jvm栈和本地方法栈三个区域随线程而生，随线程而灭，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，方法结束或者线程结束时，内存自然就随着回收了

java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题
在主流的商用程序语言中（java、c#）都是使用根搜索算法判定对象是否存活
通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的
GC Roots包括以下几种：
虚拟机栈（栈帧中的本地变量表）中引用的对象
方法区中的类静态属性引用的对象
方法区中的常量引用的对象
本地方法栈中JNI的引用的对象


在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用，强度依次减弱
强引用：只要强引用还存在。垃圾收集器永远不会回收掉被引用的对象

软引用：用来描述一些还有用，但非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收，如果这次回收还是没有足够的内存，才会抛出内存溢出异常

弱引用：也是用来描述非必需对象的，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象

虚引用：也称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知

要真正宣告一个对象死亡，至少要经过两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行筛选，筛选的条件是此对象是否有必要执行finalize()方法，如果有必要，那么这个对象将会被放置在一个队列中，并在稍后由虚拟机去依次执行finalize()方法，但并不承诺等待它运行结束。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对队列中的对象进行第二次小规模的标记，如果对象在执行finalize方法时重新把自己与GC Roots对象建立了连接，那在第二次标记时它将被移除回收集合

任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行


很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低。

新生代GC-复制算法
新生代中的对象98%是朝生夕死的，所以并需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间中，最后清理掉Eden和刚才用过的Survivor的空间。
Hotspot虚拟机默认Eden和Survivor的大小比例是8:1，只有10%的内存是会被“浪费”的
98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保

复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定
HotSpot所有实现如下：
新生代：Serial，ParNew，Parallel Scavenge
老年代：CMS，Serial Old，Parallel Old
G1

Serial：曾经是虚拟机新生代收集的唯一选择，单线程的收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，Stop The World直到它收集结束。它简单而高效，依然是虚拟机运行在Client模式下的默认新生代收集器

ParNew
就是Serial收集器的多线程版本，收集算法、Stop The World 、回收策略等都与Serial收集器完全一样
是许多运行在Server模式下的虚拟机首选的新生代收集器，除了Serial收集器外，目前只有它能与CMS收集器配合工作

在JDK1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器-CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作
它作为老年代的收集器，却无法和JDK1.4中已经存在的新生代收集器Parallel Scavenge配合工作
ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果

Parallel Scavenge也是一个新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器（不是并发收集器），目标是达到一个可控制的吞吐量，单次停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验，而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法
它有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后背预案，在并发收集器发生Concurrent Mode Failure的时候使用


CMS收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法实现的，整个过程分为4个步骤
包括：
初始标记
并发标记
重新标记
并发清除
其中初始标记、重新标记这两个步骤仍然需要STW，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短
由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的

CMS有以下三个缺点：
1.CMS收集器对CPU资源非常敏感
其实，面向并发设计的程序都对CPU资源比较敏感，在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
2.CMS收集器无法处理浮动垃圾
可能出现Concurrent Mode Failure 失败而导致另一次Full GC的产生，由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉，这一部分就称为“浮动垃圾”，也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认情况下，CMS收集器在老年代使用了68%的空间后就会被激活，可以使用-XX：CMSInitiatingOccupancyFraction的值来设计百分比。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次Concurrent Mode Failure，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了
3.收集结束时会产生大量的空间碎片

G1收集器
与CMS相比有两个改进
1.G1是基于 标记-整理 算法实现的收集器，也就是说它不会产生空间碎片
2.它可以非常精确地控制停顿，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代。而G1将整个java堆（包括新生代、老年代）划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的由来）
区域划分和有优先级的区域回收保证了G1收集器在有限的时间内可以获得最高的收集效率

UserSerialGC  使用Serial + Serial Old的收集器组合
UseParNewGC   使用ParNew + Serial Old的收集器组合
UseConcMarkSweepGC 使用ParNew + CMS + Serial Old的收集器组合
UseParallelGC 使用UseParallel Scavenge + Serial Old的收集器组合
SurviviorRatio 新生代Eden与Survivor的比例，默认为8
NewRatio 整个新生代和老年代的比值 4表示新生代:老年代 = 1:4
PretenureSizeThreshold 直接晋升到老年代的对象大小，大于这个参数的对象将直接在老年代分配
MaxTenuringThreshold 晋升到老年代的对象年龄
HandlerPromotionFailure 是否允许分配担保失败
CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发垃圾收集，默认值为68%

大多数情况下，对象在新生代Eden区中分配，当Eden区剩余空间不足以存放新建的对象时，发生Minor GC将Eden区目前所有可达的对象转移到Survivor区，如果此时Survivor区不够存放这些对象，就会通过分配担保机制将这些对象提前转移到老年代中，然后再将新建的对象放入Eden区

Major/Full GC 指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上

所谓的大对象就是指，需要大量连续内存空间的Java对象，最典型的就是很长的字符串及数组
虚拟机提供了一个PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝

PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效

如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设定为1，对象在Survivor区每熬过一次Minor GC，年龄就会增加1岁，当他的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。

比如在MaxTenuringThreshold=1时，对象会在第二次GC发生时进入老年代

动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold要求的年龄

空间分配担保
在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full
 GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。
 新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值
 取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败，如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC，虽然担保失败时绕的圈子是最大的（一次Minor GC+一次 Full GC），但大部分情况下都还是会将HandlePromotionFailure开关打开，避免频繁的Full GC

jdk工具

 给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段，这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照、堆转储快照等

 JDK bin下的工具都非常稳定而且功能强大，能在处理应用程序性能问题、定位故障时发挥很大的作用
 它们大部分都是jdk/lib/tools.jar类库的一层包装而已，主要功能代码是在tools类库中实现的
tools.jar中的类库不属于Java的标准API，如果引入这个类库，就意味着你的程序只能运行于Sun Hotspot上面

jps: JVM Process Status Tool 显示指定系统内所有的HotSpot虚拟机进程
jstat: JVM Statistics Monitoring Tool 用于收集HotSpot虚拟机的运行数据
jinfo: Configuration Info for Java 显示虚拟机配置信息
jmap: Memory Map for Java 生成虚拟机的内存转储快照
jhat: JVM Heap Dump Browser 构建一个网页，让用户可以在浏览器上查看分析结果
jstack: Stack Trace for Java 显示虚拟机的线程快照

jps可以列出正在运行的虚拟机进程pid，显示虚拟机执行主类，jvm显示指定的参数
虽然直接使用ps命令也可以查询jvm进程pid，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，就只能依赖jps命令显示的主类名称来区分了
常用命令jps -lvm

jstat工具在纯文本状态下监视虚拟机状态的变化，不如VisualVM等可视化工具那样直观

jinfo 实时查看和调整虚拟机各项参数
jps的-v参数可以查看虚拟机启动时显示指定的参数列表，但如果想知道未被显示指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项查询了

jmap
如果不使用jmap命令，想要获取java堆转储快照还有一些比较暴力的办法，比如设置-XX:HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现后自动生成dump文件，或者在Linux系统下通过Kill -3命令也能拿到dump文件
jmap的作用不仅仅是为了获取dump文件，还可以查询finalize执行队列，java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。

jhat
在实际工作中，一般不会使用该命令，一是正常不会在部署服务器上直接分析dump文件，因为分析工作耗时，消耗硬件资源
另一个原因是jhat的功能比较简陋，有很多更强大的分析工具

jstack
用于生成虚拟机当前时刻的线程快照，就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因
jdk1.5中Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象，使用这个方法可以通过简单的几行代码就完成jstack的大部分功能

jdk的可视化工具JConsole和VisualVM，是JDK的正式成员

VisualVM是jdk发布的功能最强大的运行监视和故障处理程序，它的性能分析功能甚至比起Jprofiler等专业收费工具都不会逊色多少，而且不需要被监视的程序基于特殊的Agent运行，它对应用程序的实际性能影响很小，可以直接应用在生产环境中

在大多数网站形式的应用里，主要对象的生存周期都应该是请求级或页面级的，会话级和全局级的长生命对象相对较少。只要代码写得合理，应当都能实现在超大堆中正常使用而没有Full GC，保障老年代空间的稳定。

考虑到在一台物理机器上建立逻辑集群的目的仅仅是尽可能地利用硬件资源，并不需要关心状态保留、热转移之类的高可用性需求。
可能会遇到下面一些问题
1.尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很容易导致IO异常
2.很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。
3.大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存

除了java堆和永久代之外，以下内存也会占用较多的内存
1.Direct Memory：可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或OutOfMemoryError：Direct buffer memory
2.线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配）或OutOfMemoryError:unable to create new native thread（横向无法分配）
3.Socket缓存区


java语言为了实现跨平台的特性，java代码编译出来后形成的Class文件中存储的是字节码（ByteCode），虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少，为了解决程序解释执行的速度问题，在JDK1.2之后，虚拟机内置了两个运行时编译器，如果一段Java方法被调用的次数达到一定程度，就会被判定为热代码，从而交给JIT编译器即时编译为本地代码，以提高运行速度（这就是HotSpot虚拟机名字的由来）。Java运行期编译最大的缺点就是编译需要消耗程序正常的运行时间，也就是上面所说的“编译时间”


YGC发生时依然会STW，每当发生一次垃圾收集的动作，所有的用户线程都必须跑到最近的一个安全点，然后挂起线程等待垃圾回收，这样过于频繁的GC就会导致很多没有必要的安全点检测、线程挂起及恢复操作

为了避免老年代或永久代空间扩展所带来的性能浪费，可以把-Xms和-XX:PermSize参数值分别设置为-Xmx和-XX:PermSizeMax参数值相同，强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展

JVM里有一条特殊的线程－－VM Threads，专门用来执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务，都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行。所以JVM引入了安全点(Safe Point)的概念，想办法在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。

除了GC，其他触发安全点的VM Operation包括：
JIT相关，比如Code deoptimization, Flushing code cache
Class redefinition (e.g. javaagent,hot swap,AOP代码植入的产生的instrumentation)
Biased lock revocation 取消偏向锁
Various debug operation (e.g. thread dump or deadlock check)


根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储



Class文件=魔数+版本+常量池+访问标志+类索引、父类索引和接口索引集合+字段表集合+方法表集合+属性表集合



常量池主要存放两类常量：字面量 和 符号引用
字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括了下面三类常量：
类和接口的全限定名
字段的名称和描述符
方法的名称和描述符

在Class文件中不会保存各个方法和字段的最终内存布局信息，因此这些字段和方法的符号引用不经过转换的话是无法直接被虚拟机使用的，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析并翻译到具体的内存地址之中

常量池中的每一项常量都是一个表，共有11种结构各不相同的表结构数据，这11中表都有一个共同的特点，就是表开始的第一位是一个标志位 取值为1至12
之所以说常量池是最繁琐的数据，是因为这11种常量类型各自均有自己的结构。

由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法和字段名的最大长度，所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译

在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具:javap

在常量池结束之后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或接口的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否定义为abstract类型等等

字段表
包括了类级变量或实例级变量，但不包括在方法内部声明的变量
字段的各个修饰符都是布尔值，很适合使用标志位来表示，而字段的名字和数据类型，这些都是无法固定的，只能引用常量池中的常量来描述

相对于全限定名的简单名称来说，方法和字段的描述符就要复杂一些，描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值，根据描述符规则，基本数据类型及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示
对于数据类型，每一个维度将使用一个前置的“[”字符来描述，一个整形数组int[] 将被记录为 [I
用描述符描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号之内
toString() 描述符为 ()Ljava/lang/String

字段表集合中不会列出从超类或父接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段，另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的

方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里的代码不行，方法里的java代码，经过编译器编译成字节码指令之后，存放在方法属性表集合中一个名为 Code 的属性里面

如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息，但同样的，有可能出现由编译器自动添加的方法，最典型的就是构造器方法

在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的
但是在Class文件格式中，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存的


属性表集合
属性表集合的限制宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息
Code属性 方法表使用
ConstantValue属性 字段表使用

Code属性
对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的
Java程序方法体内的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内
Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或抽象类中的方法就不存在Code属性
max_stack 代表了操作数栈深度的最大值
max_locals代表了局部变量表所需的存储空间，单位是Slot，对于基本类型、reference和returnAddress，每个局部变量占用一个Slot，而double和long需要2个Slot
方法参数、this、异常处理器的参数、方法体中定义的局部变量都需要使用局部变量表来存放，另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占的Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，编译器会根据变量的作用域来分类Slot并分配给各个变量使用，然后计算出max_locals的大小
code_length 和 code用来存储Java源程序编译后生成的字节码指令
code_length 代表字节码长度，code是用于存储字节码指令的一系列字节流
既然名为字节码指令，那么每个指令就是一个ul类型的单字节，当虚拟机读取到code中的一个字节码时，就可以相应地找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数
一个ul可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义
关于code_length 虚拟机规范中限制了一个方法不允许超过65535条字节码指令

Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（方法体里面的java代码）和元数据（包括类、字段、方法定义）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目就都用于描述元数据

在任何实例方法中，都可以通过this关键字访问到此方法所属的对象，这个访问机制对java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器在编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数即可，因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用

在字节码指令之后的是这个方法的显式异常处理表集合，异常表对于Code属性来说并不是必须存在的
异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制


Exceptions属性
与Code属性平级，和Code属性中的异常表不一样，作用是列举出方法中可能抛出的受检异常
LineNumberTable属性
用于描述java源码行号与字节码行号之间的对应关系，不是必须的属性，可以关闭，影响就是在抛出异常时，堆栈中将不会显示出错的行号，并且在debug时无法按照源码来设置断点
LocalVariableTable属性
用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系

SourceFile属性
用于记录生成这个Class文件的源码文件名称

ConstantValue属性
作用是通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以使用
对于非static类型的变量的赋值是在实例构造器方法中进行的
对于static变量，如果是String常量的话就生成ConstantValue属性来初始化，如果不是则在clinit方法中初始化

InnerClasses属性
用于记录内部类与宿主类之间的关联


代码编译的结果就是从字节码转变为本地机器码，这是存储格式发展的一小步，却是编程语言发展的一大步

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的

类被从加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了
加载、验证、准备、解析、初始化、使用和卸载七个阶段
其中验证、准备和解析三个部分统称为连接
加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定，请注意这里写的是开始，而不是进行或完成，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另一个阶段

加载类并没有严格规定开始时间，但是对于初始化阶段，虚拟机规范则是严格规定了有且只有四种情况必须对类进行初始化，而加载、验证、准备自然需要在此之前开始
1.遇到new getstatic putstatic或invokestatic这4条字节码指令时，对应场景就是使用new实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法时

2.使用java.lang.reflect包的方法对类进行反射调用的时候

3.被子类初始化触发的父类初始化

4.虚拟机启动时的主类

这四种场景的行为称为对一个类的主动引用，除此之外所有引用类的方式，都不会触发初始化，称为被动引用
例如通过子类访问父类的静态变量时，只会对父类初始化，子类并不会

如果一个类中引用了其他类的常量时，在编译期这些常量会被直接存储到该类的常量池中，所以这些常量引用都被转换为自身常量池的引用了，这两个类在编译成Class之后就不存在任何联系了，也就是说对一个类的常量引用时，并不会导致该类被加载

“加载”阶段是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
1.通过一个类的全限定名来获取定义此类的二进制字节流
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口

第一点并没有指明二进制字节流要从一个Class文件中获取，准确地说是根本没有指明要从哪里获取及怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的舞台，Java发展历程中，许多举足轻重的Java技术都建立在这一基础之上，例如：
1.从zip包中读取，最终成为日后JAR、WAR格式的基础
2.从网络中获取，例如Applet
3.运行时计算生成，比如动态代理技术
4.由其他文件生成，如JSP

相对于类加载过程的其他阶段，加载阶段（确切地说，是加载阶段中获取类的二进制字节流的动作）是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
JAVA语言本身是相对安全的，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据，将一个对象转型为它并未实现的类型等，如果这样做了，编译器将拒绝编译，但是Class文件不一定要求用Java源码编译而来，可以使用十六进制编辑器直接编写产生Class文件，在字节码的语言层面上，上述Java代码无法做到的事都是可以实现的，虚拟机如果不检查输入的字节流，很可能会因为载入了有害的字节流导致系统崩溃

验证阶段是非常重要的，且验证阶段的工作量在虚拟机的类加载子系统中占了很大一部分，如果校验不通过就抛出java.lang.VerifyError，主要包括以下校验工作：
1.文件格式验证
是否以魔数0xCAFEBABE开头，主次版本号是否在当前虚拟机处理范围之内等
这阶段的验证是基于字节流进行的，经过这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的三个验证阶段全部都是基于方法区的存储结构进行的
2.元数据验证
主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息
包括是否有父类，是否继承了不允许被继承的类，方法重载是否正确等
3.字节码验证
第三个阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：
保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
保证跳转指令不会跳转到方法体以外的字节码指令上
保证方法体中的类型转换是有效的
4.符号引用验证
最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段-解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性的校验，通常需要校验以下内容：
符号引用中通过字符串描述的全限定名是否能找到对应的类
在指定类中是否存在符合方法的字段描述符
符号引用中的类、字段和方法的访问性是否可被当前类访问
如果无法通过符号引用验证，将会抛出编译异常诸如java.lang.IllegalAccessError,java.lang.NoSuchFieldError,java.lang.NoSuchMethodError等

验证阶段不一定是必要的阶段，如果所运行的全部代码都已经被反复使用和验证过，可以使用-Xverify:none参数来关闭，以缩短虚拟机类加载的时间

准备阶段
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配，这个阶段中有两个容易混淆的概念，首先是这时候进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，其次是这里所说的初始值通常情况下是数据类型的零值
对于public static int value = 123;
那么变量value在准备阶段过后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会被执行

上面提到，在通常情况下初始值是零值，那相对的会有一些特殊情况，如果类字段的字段属性表中ConstantValue属性，那在准备阶段变量Value就会被初始化为ConstantValue属性所指定的值，对于public static final int value = 123;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123

解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。
虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行new,getstatic,invokespecial等13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析
对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存
解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行
1.类或接口的解析
假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，包括以下三个步骤：
如果C不是一个数据，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，又将可能触发其他相关类的加载动作，例如这个类的父类或接口，一旦这个加载过程出现了任何异常，解析过程就将宣告失败
如果上面的步骤没有异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认C是否具备对D的访问权限
2.字段解析
要解析一个字段符号引用，首先要对字段所属的类或接口的符号引用进行解析
如果C本身就包含与目标匹配的字段，则直接返回该字段，否则，如果C实现了接口，则按照继承关系从上往下搜索各接口，否则再按照继承关系从上到下搜索
实际上，编译器是不会允许接口与父类同时存在同一个字段的

初始化
类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作全部由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码
在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，初始化阶段是执行类构造器<clinit>()方法的过程。

<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。

<clinit>()方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object

由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作

<clinit>()方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么就可以不为这个类生成该方法

接口与类一样都会生成<clinit>()方法，但接口不需要先执行父接口的<clinit>()方法，接口的实现类在初始化时也一样

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕


类加载器


类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而被开发出来的，如今Java Applet技术基本上已经死掉，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了Java技术体系中一块重要的基石。

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这个两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。

这里的相等，包括代表类的Class对象的equals()方法，isInstance()，instanceof方法的比较结果

站在Java虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分，另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外，并且全部继承自抽象类java.lang.ClassLoader
从java开发人员的角度来看，类加载器就还可以划分得更细致一些
启动类加载器（Bootstrap ClassLoader）：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（如rt.jar）类库加载到虚拟机内存中，启动类加载器无法被Java程序直接引用

扩展类加载器(Extension ClassLoader)：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器

应用程序类加载器(Application ClassLoader):这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器

类加载器的双亲委派模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者们的一种类加载器实现方式

双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中，如果自定义的类加载器不去调用该方法就可以破除双亲委派机制

在Java的世界里面大部分的类加载器都遵循这个模型，但也有例外的情况，到现在为止，双亲委派模型主要出现过三次较大规模的被破坏情况

第一次被破坏出现在双亲委派模型出现之前，由于双亲委派模型在JDK1.2之后才引入，而类加载器和抽象类java.lang.ClassLoader在JDK1.0就已经存在，为了向前兼容，JDK1.2之后的CLassLoader添加了一个新的protected方法findClass()，在此之前，用户去继承ClassLoader的唯一目的就是为了重写loadClass方法，双亲委派的具体逻辑就实现在这个方法中，JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的


第二次是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为基础，是因为他们总是作为被用户代码调用的API，但世事无绝对，如果基础类又要调用回用户的代码，怎么处理？
一个典型的例子就是JNDI服务，它的代码由启动类加载器去加载（在JDK1.3时代放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI）的代码，但启动类加载器不可能认识这些代码
为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器
这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器
有了线程上下文类加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，Java中所有涉及SPI的加载动作基本上都采用这种方式

第三次是由于用户对程序动态性的追求而导致的，这里的动态性指的是代码热替换，模块化部署等等
OSGi是当前业界事实上的Java模块化标准，而OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。
在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索
1.将以java.*开头的类，委托给父类加载器加载
2.否则，将委派列表名单内的类，委派给父类加载器加载
3.否则，将import列表中的类，委派给Export这个类的Bundle的类加载器加载
4.否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
5.否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
6.否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
7.否则，类查找失败
上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的

虚拟机字节码执行引擎

执行引擎是Java虚拟机最核心的组成部分之一，虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式
在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能包含几个不同级别的编译器执行引擎。但从外观来看，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果

编译型语言，如C，事先将源码编译成机器码，执行速度快，但是不能跨平台，对不同的机器需要编译成不同的机器码
解释型语言，如js，在运行时由解释器读取源码根据不同的机器翻译成不同的机器码执行，速度较慢，可跨平台
编译+解释型语言，如Java，事先将源码编译成字节码，字节码可跨平台，在执行时由虚拟机字节码执行引擎翻译成对应的机器码执行

运行时栈帧结构
栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机里面从入栈到出栈的过程。
每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量、多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作

局部变量表
是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量
局部变量表的容量以变量槽Slot为最小单位，一个Slot可以存放一个32位以内的数据类型，包括6种基本类型和reference、returnAddress，reference是对象的引用，虚拟机规范既没有说明它的长度，也没有明确指出这个引用的结构，但是一般来说，虚拟机实现至少都应当能从此引用中直接或间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。而returnAddress是指向了一条字节码指令的地址。
Java语言中明确规定的64位的数据类型只有long和double两种。

在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法，那么局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字this来访问这个隐含的参数
局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用，这样的设计不仅仅是为了节省栈空间，在某些情况下Slot的复用会直接影响到系统的垃圾收集行为，方法中的变量在离开作用域之后就会从GC Roots中剔除，便于该变量占用的空间今早被回收。
如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再被使用的变量，手动将其设置为null就不是一个毫无意义的操作，但不应当对赋null操作有过多的依赖，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法

局部变量不像类变量那样存在准备阶段，类变量有两次赋值初始化的过程，一次在准备阶段，赋予系统初始值，另一次在初始化阶段，赋予程序员定义的初始值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值，但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的，编译就不会通过

操作数栈
操作数栈也常被称为操作栈，它是一个后入先出栈，同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值
当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。例如，在做算术运算的时候是通过操作数栈来进行的
整数加法的字节码指令iadd在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。
操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整数相加，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况

在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。这样在进行方法调用时就可以共用一部分数据，而无须进行额外的参数复制传递了

Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈

动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这个转化成为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分成为动态连接

方法返回地址
当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定。
另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，这种退出方法的方式称为异常完成出口
无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。

方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前所说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。

解析
所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用被称为解析。

在Java语言中，符合 编译器可知，运行期不可变 这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他版本，因此他们都适合在类加载阶段进行解析。
与之对应，在Java虚拟机里面提供了四条方法调用字节码指令，分别是：
invokestatic:调用静态方法
invokespecial:调用实例构造器<init>方法、私有方法和父类方法
invokevirtual:调用所有的虚方法
invokeinterface:调用接口方法，会在运行时再确定一个实现此接口的对象
只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为非虚方法，与之相反，其他方法就称为虚方法。
Java中的非虚方法除了使用invokestatic和invokespecial调用的方法之外还有一种，就是被final修饰的方法，虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接受者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。

解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况

分派
众所周知，Java是一门面向对象的程序设计语言，因为java具备面向对象的三个基本特征：继承、封装和多态
1.静态分派
Human man = new Man();
我们把上面代码中的Human称为变量的静态类型或者外观类型，后面的Man则称为变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么，如：
//实际类型变化
Human man = new Man();
man = new Women();
//静态类型变化
sr.sayHello((Man)man);
sr.sayHello((Women)man);
编译器在重载时是通过参数的静态类型而不是实例类型作为判定依据的，并且静态类型是编译器可知的，所以在编译阶段，Javac编译器就根据参数的静态类型决定使用哪个重载版本

所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是唯一的，往往只能确定一个更加合适的版本，而且是按照特定的优先级确定，从自动类型转换 -> 自动拆装箱 -> 继承关系类从下往上 -> 可变长参数方法 优先级依次降低

动态分派
它与多态性的另外一个重要体现-重写有着很密切的关联（有一种观点认为：因为重载是静态的，重写是动态的，所以只有重写算是多态性的体现）

invokevirtual指令的运行时解析过程大致如下：
1.找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
2.如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，不通过则返回IllegalAccessError异常
3.否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程
4.如果始终没有找到合适的方法，则抛出AbstractMethodError异常
由于invokevirtual指令执行的第一步就是在运行期确定接受者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质，我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

单分派与多分派
方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个的宗量对目标方法进行选择

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真的进行如此频繁的搜索。面对这种情况，最常用的稳定优化手段就是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会被替换为指向子类实现版本的入口地址。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕

字节码解释执行引擎
许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择
解释执行
Java语言经常被人们定位为解释执行的语言，在Java出生的时代，这种定义还算是比较准确的，但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事。再后来，Java发展出了可以直接生成本地代码的编译器（如GCJ，GNU Compile for the Java），而C/C++语言也出现了通过解释器执行的版本（如CINT），这时候再笼统地说“解释执行”对于整个Java语言来说几乎就是没有意义的概念了


程序源码 - 词法分析 - 单词流 - 语法分析 - 抽象语法树 - 指令流 - 解释器 - 解释执行
                                        - 优化器 - 中间代码 - 生成器 - 目标代码

如今，基于物理机、Java虚拟机或者是非Java的其他高级语言虚拟机的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树。对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以选择把其中一部分步骤实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如JavaScript执行器

Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现

基于栈的指令集与基于寄存器的指令集

Java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，更通俗一些，就是现在我们主流PC中直接支持的指令集架构，这些指令依赖寄存器进行工作。
对于1+1的结果，基于栈的指令集：
iconst_1
iconst_1
iadd
istore_0
两条iconst_1指令连续地把两个常量1压入栈后，iadd指令把栈顶的两个值出栈并相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中

如果是基于寄存器的指令集
mov eax, 1
add eax, 1
mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面

基于栈的指令集最主要的优点就是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。
例如，现在32位x86体系的处理器中提供了8个32位的寄存器，而ARM体系的CPU（在当前的手机、pad中相当流行的一种处理器）则提供了16个32位的通用寄存器。如果使用栈架构的指令集，用户程序不会直接用到这些寄存器，那就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存）放到寄存器中以获得尽量好的性能，这样实现起来更加简单。

栈架构指令集的主要缺点是执行速度相对来说稍慢一些。

栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令。更重要的是栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中以避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。因此，由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度相对较慢。

主流的Java Web服务器都实现了自己定义的类加载器，因为一个功能健全的Web服务器，都要解决如下几个问题：
1.部署在同一个服务器上的多个Web应用程序所使用的Java类库可以实现相互隔离，不同的应用程序可能会依赖同一个第三方类库的不同版本
2.部署在同一个服务器上的多个Web应用程序所使用的Java类库可以实现互相共享，如果类库不能共享，虚拟机的方法区很容易就会出现过度膨胀的风险
3.服务器自身使用的类库应该与应用程序的类相互独立
4.支持JSP应用的Web服务器，十有八九都需要支持HotSwap功能。JSP文件最终要被编译成Java Class才能被虚拟机执行，但JSP文件由于其纯文本存储的特性，被运行时修改的概率远远大于第三方类库或程序自己的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待，因此“主流”的Web服务器都会支持JSP生成类的热替换
由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足需求了，所以各种Web服务器都不约而同地提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般都以“lib”或“classes”命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常，每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库

在Tomcat目录结构中，有三组目录（"/common/*"、"/server/*"、"/shared/*"），再加上Web应用程序自身的目录"/WEB-INF/*"，一共四组
1.放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用
2.放置在/server目录中：类库可被Tomcat使用，对所有的Web应用程序都不可见
3.放置在/shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见
4.放置在/WebApp/WEB-INF目录中：类库仅仅可以被此Web应用程序使用
为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现
CommonClassLoader,CatalinaClassLoader,SharedClassLoader和WebappClassLoader是Tomcat自己定义的类加载器，分别加载上述四个路径下的Java类库，其中WebApp类加载器和JSP类加载器通常会存在多个实例，每个Web应用程序对应一个WebApp类加载器，每一个Jsp文件对应一个Jsp类加载器

CommonClassLoader加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，而CatalinaClassLoader和SharedClassLoader加载的类互相隔离，WebappClassLoader可以使用SharedClassLoader加载到的类，但各个WebappClassLoader实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class，它出现的目的就是为了被丢弃，当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能

JasperLoader -> WebappClassLoader -> SharedClassLoader -> CommonClassLoader -> AppClassLoader -> ExtClassLoader -> BootClassLoader 
                                   CatalinaClassLoader ->

对于新版的Tomcat，只有指定了tomcat/conf/catalina.properties配置文件的server.loader和share.loader项后才会真正建立CatalinaLoader和SharedClassLoader的实例，否则都用CommonClassLoader来代替，而默认是没有设置这两项的，所以Tomcat会直接把/common,/server,/share三个目录默认合并到一起变成一个/lib目录，是为了简化大多数的部署场景所做的一项改进

OSGi(Open Service Gateway Initiative)
是OSGi联盟制订的一个基于Java语言的动态模块化规范，现在已经成为Java世界中“事实上”的模块化标准，最著名的应用案例就是Eclipse IDE

OSGi中每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以Jar格式进行封装，并且内部存储的都是Java Package和Class，但是一个Bundle可以声明它所依赖的Java Package，也可以声明它允许导出发布的Java Package。在OSGi里面，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性得到了非常精确的控制，引入OSGi的另外一个重要理由是，基于OSGi的程序很可能（只是很可能，并不是一定会）可以实现模块级的热插拔功能，当程序升级更新或调试除错时，可以只停用、重新安装然后启用程序的其中一部分，这对企业级程序开发来说是一个非常有诱惑力的特性。

在OSGi里面，加载器之间的关系不再是双亲委派模型的树形结构，而是已经进一步发展成了一种运行时才能确定的网状结构。这种网状的类加载器架构在带来更优秀的灵活性的同时，也可能会产生许多新的隐患，比如死锁，因为java.lang.ClassLoader.loadClass()内部是同步的，如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A，在高并发环境下进行类加载就很容易发生死锁。

总体来说，OSGi描绘了一个美好的模块化开发的目标，而且定义了实现这个目标所需要的各种服务，同时也有成熟框架对其提供实现支持。但OSGi在提供强大功能的同时，也引入了额外的复杂度，带来了线程死锁和内存泄漏的风险。


字节码生成技术与动态代理的实现
“字节码生成”并不是什么高深的技术，不必先去想诸如Javassist，CGLib和ASM之类的字节码类库，因为JDK里面的javac命令就是字节码生成技术的“老祖宗”，并且javac也是一个由java语言写成的程序，在Java里面除了javac和字节码类库外，使用到字节码生成的例子还有很多，如Web服务器中的JSP编译器，编译时织入的AOP框架，还有很常用的动态代理技术

动态代理中所谓的“动态”是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中

Retrotranslator:跨越JDK版本，逆向移植工具
一般来说，以做项目为主的软件公司比较容易更新技术，在下一个项目中换一个技术框架、升级JDK版本、甚至替换语言都是有可能的，但以做产品为主的公司，自主选择技术的权利就会丧失掉，一个稳健的团队也不会随意地改变底层的技术

JDK的每次升级中新增的功能大致可以分为以下几类：
1.在编译期层面所做的改进。如自动装箱拆箱，实际上就是编译器在程序中使用到包装对象的地方自动插入了很多的Integer.valueOf()之类的代码；变长参数在编译之后就被自动转化成了一个数组来完成参数传递；泛型的信息则在编译阶段就已经被擦除掉了，相应的地方被编译器自动插入了类型转换代码
2.对Java API的代码增强，譬如JDK1.2时代引入的java.util.Collections等一系列集合类，在JDK1.5时代引入的java.util.concurrent并发包等
3.需要在字节码中进行支持的改动，比如动态语言支持就需要在虚拟机中新增一条invokedynamic字节码指令来实现相关的调用功能
4.虚拟机内部的改进
比如CMS收集器之类的
上述四种，Retrotranslator只能模拟前两类

使用enum关键字定义常量，虽然从Java语法上看起来与使用class关键字定义类是同一层次的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看，枚举仅仅是一个继承与java.lang.Enum，自动生成了values()和valueOf()方法的普通Java类而已

JDK1.6之后提供了Compiler API,可以动态地编译Java程序
JavaCompiler不仅能编译硬盘上的Java文件，而且还能编译内存中的Java代码，然后使用reflection来运行他们。我们能编写一个JavaSourceFromString类，通过这个类能输入Java原始码。一但建立这个对象，你能向其中输入任意的Java代码，然后编译和运行，而且无需向硬盘上写.class文件

java语言的“编译期”是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确些）把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码的过程

前端编译器：Sun的Javac, Eclipse JDT
JIT编译器：HotSpot VM的C1，C2编译器
AOT编译器：GCJ(GNU Compiler for the Java)

Javac编译器对代码的运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化所带来的好处，但是Javac做了许多针对编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的语法糖来实现，而不是依赖虚拟机的底层改进来支持

Javac编译器不像HotSpot虚拟机那样使用C++语言实现，它本身就是一个由Java语言编写的程序

虚拟机规范严格定义了Class文件的格式，但是对如何把Java源码文件转变为CLass文件的编译过程未作任何定义，所以这部分内容是与具体JDK实现相关的。从Sun Javac的代码来看，编译过程大致可以分为三个过程
1、解析与填充符号表过程
2、插入式注解处理器的注解处理过程
3、分析与字节码生成过程

词法分析是将源代码的字符流转变为标记（Token）集合，标记是编译过程的最小元素，关键字、变量名、字面量和运算符都可以成为标记
语法分析是根据Token序列来构造抽象语法树（AST）的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式

在JDK1.6中提供了一组插入式注解处理器的标准API在编译期对注解进行处理，我们可以把它看做是一组编译期的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止

有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为

语义分析主要任务是对结构上正确的源程序进行上下文有关性质的审查，即保证程序上下文逻辑上的正确性

1.常量折叠 int a = 1 + 2; 经过编译器常量折叠后 -> int a = 3;

2.局部变量final语义校验
public void foo(final int arg){
	final int var = 0;
}
public void foo(int arg){
	int var = 0;
}
这两段代码编译出来的Class文件是没有任何一点区别的，因为局部变量与字段是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志的信息，甚至可能连名称都不会被保留下来，自然在Class文件中不可能知道一个局部变量是不是被声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。

3.解语法糖
语法糖也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会
Java在现代编程语言之中属性“低糖语言”，Java中最常用的语法糖主要是泛型（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱拆箱，虚拟机运行时不支持这些语法，它们在编译阶段被还原回简单的基础语法结构，这个过程就称为解语法糖desugar

4.字节码生成
字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转化工作
比如实例构造器<init>()方法和类构造器<clinit>()方法就是在这个阶段被添加到语法树之中的，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成，这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，虚拟机会自动保证父类构造器的执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）等操作收敛到<init>()和<clinit>()方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行

泛型是JDK1.5的一项新特性，它的本质是参数化类型的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。

在Java语言还没有出现泛型时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会被转嫁到程序运行期中。

泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的中间语言中还是运行期的CLR中都是切实存在的，List<Integer>与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型被称为真实泛型

Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原生类型了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<Integer>与ArrayList<String>就是同一个类,Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型
public class GenericTypes {
	public static void method(List<String> list){}
	public static void method(List<Integer> list){}
}
参数List<Integer>和List<String>编译之后都被擦除了，变成了一样的原生类型List<E>，擦除动作导致这两个方法的特征签名变得一样
public class GenericTypes {
	public static String method(List<String> list){return "";}
	public static int method(List<Integer> list){return 1;}
}
这段代码可以被编译执行
因为虽然方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，但是在CLass文件格式之中，只要描述符不是完全一致的两个方法就可以共存。也就是说两个方法如果有相同的名称和特征名称，但返回值不同，那它们也是可以合法地共存于一个Class文件中的

由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求
从上面的例子可以看到擦除法对实际编码带来的影响，由于List<String>和List<Integr>擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载，这是一种毫无优雅和美感可言的解决方案。同时，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。

forin循环是把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因
包装类的“==”运算在没有遇到运算的情况下不会自动拆箱

条件编译
Java编译器并非一个一个地编译Java文件，而是将所有的编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息

public static void main(String[] args){
	if(true){
		System.out.println("block 1");
	} else {
		System.out.println("block 2");
	}
}
此代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包括System.out.println("block 1");

编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序写得对不对为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序写得好不好。有鉴于此，业界出现了许多针对程序写得好不好的辅助校验工具

即时编译器并不是虚拟机必需的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器，但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心最能体现技术水平的部分

解释器和编译器两者各有优势：当程序需要迅速启动的执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的内存编译成本地代码之后，可以获取更高的执行效率。
当程序运行环境中内存资源限制较大，可以使用解释执行节省内存，反之可以使用编译执行来提升效率

HotSpot虚拟机中内置了两个即时编译器，称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器
程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用-client或-server参数指定

在运行过程中会被即时编译器编译的热点代码有两类，即
被多次调用的方法
被多次执行的循环体所在的方法

在HotSpot虚拟机中使用的是基于计数器的热点探测方法，它为每个方法准备了两个计数器：方法调用计数器和回边计数器
在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译

默认阈值在Client模式下是1500次，在Server模式下是10000次，当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行，如果不存在，则将此方法的调用计数器值加一

在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数

回边计数器用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为回边
与方法计数器不同，回边计数器没有热度衰减的过程

方法内联
是编译器最重要的优化手段之一，方法内联的优化行为看起来很简单，不过是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用而已，但实际上Java虚拟机中的内联过程远远没有那么简单，因为在Java中只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和静态方法才是在编译期进行解析的，Java语言中默认的实例方法就是虚方法，需要在运行时才能确定版本

物理机的多线程问题
多处理器 高速缓存一致性问题 （缓存一致性协议）
处理器代码乱序执行

Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件（或者说操作系统的内存模型），因此，会由于不同平台上内存模型的差异，导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此经常需要针对不同的平台来编写程序


Java内存模型规定了所有的变量（实例变量）都存储在主内存中（是指虚拟机内存的一部分）。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

这里说的主内存、工作内存与Java内存区域中的Java堆、栈、方法区并不是同一层次的内存划分。主内存主要对应于Java堆中对象的实例数据部分（除了实例数据，Java堆中还保存了对象的哈希码、GC标志、GC年龄、同步锁等信息），而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中

1. 寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。
2. 内存包含的范围非常广，一般分为只读存储器（ROM）、随机存储器（RAM）和高速缓存存储器（cache）。
3. 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。
4. Cache ：即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。

总结：大致来说数据是通过内存-Cache-寄存器，Cache缓存则是为了弥补CPU与内存之间运算速度的差异而设置的的部件。

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下八种操作来完成（原子性操作）：
lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来
read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load使用
load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序地执行store和write操作，除此之外还必须满足如下规则：
不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现

不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存

不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中

一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作

一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁

如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值

如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量

对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）

volatile禁止指令重排序
指令重排序本身对单线程的程序并不会有任何影响，即时指令被重排序，普通的变量也能保证在方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，但是对多线程的程序，如果某个线程依赖于另一个线程的执行结果，当另一个线程内部产生指令重排序时，可能会对该线程产生意料之外的影响，而volatile关键字可以避免此类情况发生

在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器都遵从这一目标。
这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。这是就需要内存屏障来保证可见性了。

volatile变量读操作的性能消耗与普通变量几乎没有什么区别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行

Java内存模型中对volatile变量定义的特殊规则
线程T volatile变量V和W
1.只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作
只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作
这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值

2.只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作
只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作
这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改

3.假定动作A是线程T对变量V实施的use或assign动作，动作F是与动作A相关联的load或store动作，
动作P是与动作F相应的对变量V的read或write动作
假定动作B是线程T对变量W实施的use或assign动作，动作G是与动作B相关联的load或store动作
动作Q是与动作G相应的对变量W的read或write动作
如果A先于B，那么P先于Q
这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同

内存屏障
内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。
内存屏障有两个作用：

1.阻止屏障两侧的指令重排序；
2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。

对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；
对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。
java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。

LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：
在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；
在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；
由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。


Java内存模型要求lock、unlock、read、load、assign、use、store和write这八个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的非原子性协定
如果有多个进程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值
不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还强烈建议虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要将用到的long和double变量声明为volatile

原子性 
由Java内存模型来直接保证的原子性变量操作包括read,load,assign,use,store和write
如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块synchronized关键字

可见性
Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点
除了volatile之外，Java还有两个关键字能实现可见性，synchronized和final
同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到初始化了一半的对象），那么在其他线程中就能看见final字段的值

有序性
Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的，前半句是指 线程内表现为串行的语义，后半句是指 指令重排序 现象和 工作内存与主内存同步延迟 现象
Java的有序性也是靠synchronized和volatile关键字保证
volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入

先行发生原则happens-before
先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

下面是Java内存模型下一些天然的先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序
1.程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序
2.管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
3.volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
4.线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作
5.线程终止规则
6.线程中断规则
7.对象终结规则
8.传递性

一个操作 时间上的先发生 不代表这个操作会是 先行发生
一个操作 线程发生 也不代表这个操作会在 时间上先发生

线程
并发不一定要依赖多线程，如PHP中很常见的多进程并发，但Java里的并发，大多数都与线程脱不开关系
Thread类所有关键方法都被声明为native
实现线程主要有三种方式：使用内核线程实现，使用用户线程实现，使用用户线程加轻量级进程混合实现

线程主要调度方式有两种：协同式线程调度 和 抢占式线程调度
协同式调度，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上去。好处是线程切换对于线程自己是可知的，所以没有线程同步的问题，Lua语言中的“协同例程”就是这类实现，坏处就是线程执行时间不可控制，如果一个线程编写有问题，程序就会一直阻塞
抢占式调度，每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的），线程的执行时间是系统可控的，Java线程就是抢占式调度

虽然Java线程调度是系统自动完成的，但我们还是可以通过设置线程优先级来建议系统给某些线程多分配一点时间，不过，线程优先级并不是太靠谱，原因是Java的线程是被映射到系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算

Java语言定义了5种线程状态
新建（New）：创建后尚未启动的线程处于这种状态
运行（Runable）：Runable包括了Running和Ready
无限期等待(Waiting):处于这种状态的进程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒，以下方法会让线程陷入无限期的等待状态：
没有设置TimeOut的Object.wait()方法
没有设置TimeOut的Thread.join()方法
LockSupport.park()方法

限期等待：在一定时间之后会由系统自动唤醒
Thread.sleep方法
设置了TimeOut的Object.wait()方法
设置了TimeOut的Thread.join()方法

阻塞：等待获取排它锁

结束：已终止线程的状态


可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立
1.不可变
不可变对象一定是线程安全的
对于基本数据类型，只要在定义时使用final关键字修饰它就可以保证它是不可变的
如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，例如String
保证对象行为不影响自己状态的途径有很多种，最简单的就是把对象中带有状态的变量都声明为final，例如Integer

Java常见不可变类型，除了String，还有枚举类型，Number的部分子类，BigInteger和BigDecimal

2.绝对线程安全

3.相对线程安全
就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用时不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性
4.线程兼容
通常意义上的线程不安全

5.线程对立
无论如何都无法保证线程安全，例如Thread类的suspend()和resume()

线程安全的实现方法
1.互斥同步
在Java里面，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference，如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。
根据虚拟机规范的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，就把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步快在已进入的线程执行完之前，会阻止后面其他线程的进入。Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块，状态转换消耗的时间可能比用户代码执行的时间还要长。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。

自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快

除了synchronized之外，我们还可以使用JUC包中的重入锁ReentrantLock来实现同步，而且相比synchronized多了一些高级特性
1.等待可中断
是指持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
2.支持公平锁
是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁，synchronized是非公平锁，ReentrantLock默认也是非公平的，但是可以通过带布尔值的构造函数要求使用公平锁
3.锁绑定多个条件
是指一个ReentrantLock对象可以同时绑定多个Condition对象

JDK1.6之后，两者的性能基本持平了，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步

2.非阻塞同步
互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也被称为阻塞同步
它属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，而乐观策略就是先进行操作，如果没有其他线程争用共享数据，那操作就成功，如果有争用，产生了冲突，那就再进行其他的补偿措施，常见的就是不断地重试，直到成功为止
为什么使用乐观并发策略需要 硬件指令集的发展 呢？因为我们需要操作和冲突检测这两个步骤具有原子性，只能靠硬件来完成这件事情
常见的原子性指令如下：
测试并设置（Test and Set）
获取并增加（Fetch and Increment）
交换（Swap）
比较并交换（Compare and Swap）

CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作

CAS只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

在JDK1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类提供
由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器加载的Class才能访问它），如果不采用反射手段，我们只能通过其他的Java API来间接使用它

public final int getAndIncrement(){
	for(;;){
		int current = get();
		int next = current + 1;
		if(compareAndSet(current, next))
			return current;
	}
}

JUC为了解决ABA问题，提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较鸡肋，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效

3.无同步方案（无需同步）
可重入代码：也叫纯代码，所有的可重入的代码都是线程安全的
可重入代码特征：不依赖存储的堆上的数据和公用的系统资源，用到的状态量都由参数传入
如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就是可重入的

线程本地存储：保证所有共享数据的代码都是在同一个线程中执行
最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”的处理方式，可以使用线程本地存储来解决线程安全问题

JAVA语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”
如果一个变量要被某个线程独享，可以通过ThreadLocal来实现

锁优化
高效并发是JDK1.6的一个重要主题，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。我们可以让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，为了让线程等待，我们只须让线程执行一个忙循环，这项技术就是所谓的自旋锁
自旋锁在JDK1.6中就已经改为默认开启了，但自旋等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，如果锁被占用的时间很短，自旋等待的效果就会很好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，反而带来性能的浪费。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了
JDK1.6中引入了自适应的自旋锁，自旋的时间不再固定，而是动态变化的

锁消除
虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就无须进行

锁粗化
如果一系列的连续操作都对同一个对象反复加载和解锁，甚至是在循环内加锁，虚拟机将会把加锁同步的范围扩展（粗化）到整个操作序列的外部

轻量级锁
轻量级锁是JDK1.6中加入的新型锁机制，轻量是相对于使用操作系统互斥量来实现的传统锁而言的，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗

HotSpot虚拟机对象内存布局
HotSpot对象头分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希吗，GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits，官方称它为 MarkWord。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还有有一个额外的部分用于存储数组长度
对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，MarkWord被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，MarkWord的32个Bits中25Bits用于存储对象哈希码，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位（01未锁定，00轻量级锁定，10膨胀锁，11GC标记，01可偏向锁），1Bits固定为0

同一个对象处于不同标志位时，MarkWord是不同的

                             对象头
             MarkWord                       Class Metadata
           bit field              标志位
  hashCode  分代年龄   无偏向       01     指向元数据对象的指针
   线程id   分代年龄   有偏向       01     指向元数据对象的指针
    指向线程栈中锁记录的指针        00     指向元数据对象的指针
        指向互斥量的指针            10     指向元数据对象的指针
              空                    11     指向元数据对象的指针


轻量级锁的执行过程，在代码进入同步块的时候，如果此同步对象没有被锁定（锁定标志位为01状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目标的MarkWord拷贝，然后，虚拟机将使用CAS操作尝试将对象的MarkWord更新为指向Lock Record的指针，如果更新成功了，那么这个线程就拥有了该对象的锁，并且对象MarkWord的锁标志位将转变为00

如果这个更新操作失败了，虚拟机首先会检查对象的MarkWord是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了，然后当前线程会自旋等待，自旋等待失败后轻量级锁就膨胀为重量级锁，锁的标志位变为“10”
对于解锁过程，如果对象的MarkWord仍然指向着线程的锁记录，那就用CAS操作把对象当前的MarkWord和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了

如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但是如果存在锁竞争，处理互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比重量级锁更慢

偏向锁
轻量级锁是在无竞争的情况下使用CAS操作消除同步使用的互斥量，偏向锁是在无竞争的情况下把整个同步都消除掉
当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking,Unlocking以及对MarkWord的Update）


Dalvik是Google公司自己设计用于Android平台的Java虚拟机，它是Android平台的重要组成部分，支持dex格式（Dalvik Executable）的Java应用程序的运行。dex格式是专门为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Google对其进行了特定的优化，使得Dalvik具有高效、简洁、节省资源的特点。从Android系统架构图知，Dalvik虚拟机运行在Android的运行时库层。

Dalvik充分利用Linux进程管理的特定，对其进行了面向对象的设计，使得可以同时运行多个进程，而传统的Java程序通常只能运行一个进程，这也是为什么Android不采用JVM的原因。Dalvik为了达到优化的目的，底层的操作大多和系统内核相关，或者直接调用内核接口。另外，Dalvik早期并没有JIT编译器，直到Android2.2才加入了对JIT的技术支持。

Java虚拟机运行的是Java字节码，而Dalvik虚拟机运行的是专有文件格式dex。在Java程序中，Java类会被编译成一个或多个class文件，然后打包到jar文件中，接着Java虚拟机会从相应的class文件和jar文件中获取对应的字节码。Android应用虽然也使用Java语言，但是在编译成class文件后，还会通过DEX工具将所有的class文件转换成一个dex文件，Dalvik虚拟机再从中读取指令和数据。dex文件除了减少整体的文件尺寸和I/O操作次数，也提高了类的查找速度。

Art虚拟机
即Android Runtime，Android 4.4发布了一个ART运行时，准备用来替换掉之前一直使用的Dalvik虚拟机。
ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。

JVM自定义参数通过java命令的可选项:
-D<name>=<value>
来传入JVM，传入的参数作为system的property。因此在程序中可以通过下面的语句获取参数值：
System.getProperty(<name>)
Spring显示获取properties配置文件内容
Environment.getProperty

环境变量getenv()   ：用于获取当前系统环境的字符串映射视图
USERPROFILE        ：用户目录
USERDNSDOMAIN      ：用户域
PATHEXT            ：可执行后缀
JAVA_HOME          ：Java安装目录


系统属性getProperty()   ：当前的系统属性
os.name ：操作系统的名称
os.arch  ：操作系统的架构
os.version  ：操作系统的版本
file.separator ：文件分隔符
path.separator ：路径分隔符
line.separator ：行分隔符
user.name ：用户的账户名称
user.home ：用户的主目录
user.dir：用户的当前工作目录
