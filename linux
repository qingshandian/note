linux

Multics -> (Thompson)Unics -> (C语言重新改写与编译Unics的核心)Unix 
由于Unix是以较高阶的C语言写的，相对于汇编语言需要与硬件有密切的配合，高阶的C语言与硬件的相关性就没有这么大了！所以，这个改变也使得Unix很容易被移植到不同的机器上面
AT&T由于商业的考虑，以及在当时现实环境下的思考，于是想将Unix的版权收回去。因此，AT&T在1979年发行的第七版Unix中，特别提到了『不可对学生提供原始码』的严格限制！同时，也造成Unix业界之间的紧张气氛，并且也引爆了很多的商业纠纷

-> (谭宁邦教授)Minix


GNU 史托曼 GNU C Compiler(gcc)

从(1)早期的贵森森的大型主机分配数个终端机的集中运算机制，到(2)2010 年前个人计算机运算能力增强后，大部分的运算都是在桌机或笔电上自行达成，再也不需要跑去大型主机取得运算资源了！到现在(3)由于行动装置的发达，产生的庞大数据需要集中处理，因而产生云端系统的需求！让信息/资源集中管理

如何结合目录树的架构与磁盘内的数据

所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下；也就是说，进入该目录就可以读取该分区槽的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。由于整个Linux系统最重要的是根目录，因此根目录一定需要挂载到某个分区槽的。至于其他的目录则可依用户自己的需求来给予挂载到不同的分区槽

假设我的硬盘分为两槽，partition 1是挂载到根目录，至于partition 2则是挂载到/home这个目录。这也就是说，当我的数据放置在/home内的各次目录时，数据是放置到partition 2的，如果不是放在/home底下的目录，那么数据就会被放置到partition 1了

windows 也是用挂载的观念，只不过windows是把不同的逻辑盘挂在到某个硬盘，Linux是把某个目录挂在到某个硬盘

通常小型企业或者是学校单位大多仅会有一条对外的联机，然后全公司/学校内的计算机全部透过这条联机连到因特网上。此时我们就得要使用IP分享器来让这一条对外联机分享给所有的公司内部员工使用。那么Linux能不能达到此一IP分享的功能呢？当然可以，就是透过NAT服务即可达成这项任务了！在这种环境中，由于Linux作为一个内/外分离的实体，因此网络流量会比较大一点。此时Linux主机的网络卡就需要比较好些的配备。其他的CPU、RAM、硬盘等等的影响就小很多。事实上，单利用Linux作为NAT主机来分享IP是很不智的～因为PC的耗电能力比IP分享器要大的多～那么为什么你还要使用Linux作为NAT呢？因为Linux NAT还可以额外的加装很多分析软件，可以用来分析客户端的联机，或者是用来控制带宽与流量，达到更公平的带宽使用

DHCP自动获取IP

指令, 选项, 参数等这几个咚咚中间以空格来区分，不论空几格shell 都视为一格。所以空格是很重要的特殊字符！
在Linux 系统中，英文大小写字母是不一样的。举例来说，cd 与CD 并不同

在指令列模式里面下达指令时，会有两种主要的情况：
一种是该指令会直接显示结果然后回到命令提示字符等待下一个指令的输入；
一种是进入到该指令的环境，直到结束该指令才回到命令提示字符的环境


通常出现『command not found』的可能原因为：
这个指令不存在，因为该软件没有安装之故。解决方法就是安装该软件；
这个指令所在的目录目前的用户并没有将他加入指令搜寻路径中



man命令
1用户在shell环境中可以操作的指令或可执行文件
5配置文件或者是某些文件的格式
8系统管理员可用的管理指令
man -k param 根据关键字查找命令


总结一下：
[Tab] 接在一串指令的第一个字的后面，则为『命令补全』；
[Tab] 接在一串指令的第二个字以后时，则为『文件补齐』！
若安装bash-completion 软件，则在某些指令后面使用[tab] 按键时，可以进行『选项/参数的补齐』功能！
双击tab罗列出所有符合条件的命令或者文件

[Ctrl]-c 按键 中断目前程序或者指令的运行

[Ctrl]-d 按键 通常代表着：『键盘输入结束(End Of File, EOF 或End Of Input)』的意思
也可以用来取代exit的输入呢！例如你想要直接离开文字接口，可以直接按下[Ctrl]-d就能够直接离开了(相当于输入exit)

文本模式登入后所取得的程序被称为壳(Shell)，这是因为这支程序负责最外面跟使用者(我们)沟通，所以才被戏称为壳程序
Linux的壳程序就是厉害的bash这一支

加入选项设定时，通常选项前会带-号，例如-h；有时候会使用选项的完整全名，则选项前带有--符号，例如--help；

第一个被输入的数据绝对是指令或者是可执行的文件

通常--help 用在协助你查询『你曾经用过的指令所具备的选项与参数』而已，如果你要使用的是从来没有用过得指令，或者是你要查询的根本就不是指令，而是文件的『格式』时，那就得要透过man page
--help一般用来解释命令的参数 man用来说明命令本身

惯用的关机指令：shutdown重新启动，关机：reboot, halt, poweroff

su - 切换管理员身份 exit退出管理员身份

目录的执行权限指的是进入该目录的权限

root基本上是不受系统的权限所限制的，所以无论文件权限为何，预设root都可以存取

chmod [-R] xyz 文件或目录
r:4
w:2
x:1
chmod 777 filename

权限对于文件来说，他的意义是这样的：
r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等；
w (write)：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)；
x (eXecute)：该文件具有可以被系统执行的权限。

针对目录时
r (read contents in directory)：表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。所以你就可以利用ls 这个指令将该目录的内容列表显示出来！

w (modify contents of directory)：这个可写入的权限对目录来说，是很了不起的！因为他表示你具有异动该目录结构列表的权限，也就是底下这些权限：
o建立新的文件与目录；
o删除已经存在的文件与目录(不论该文件的权限为何！)
o将已存在的文件或目录进行更名；
o搬移该目录内的文件、目录位置

x (access directory)：
目录的x代表的是用户能否进入该目录成为工作目录的用途！所谓的工作目录(work directory)就是你目前所在的目录

注意文件删除的权限设置在文件所在目录的写权限而不是在文件本身的写权限
要想读取某个目录下的文件内容，则该目录的执行权限是必须的，读权限可以没有

基本上，Linux的文件是没有所谓的『扩展名』的，我们刚刚就谈过，一个Linux文件能不能被执行，与他的第一栏的十个属性有关，与文件名根本一点关系也没有。这个观念跟Windows的情况不相同

可以被执行跟可以执行成功是不一样的～举例来说，在root家目录下的initial-setup-ks.cfg 是一个纯文本档，如果经由修改权限成为-rwxrwxrwx 后，这个文件能够真的执行成功吗？当然不行～因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力，但是能不能执行成功，当然就得要看该文件的内容

然如此，不过我们仍然希望可以藉由扩展名来了解该文件是什么东西，所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：
*.sh ：脚本或批处理文件(scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成.sh 
*Z, *.tar, *.tar.gz, *.zip, *.tgz：经过打包的压缩文件。这是因为压缩软件分别为gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名

基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行

Linux目录配置的依据--FHS
/usr (软件放置处)
/etc (配置文件)
/opt (第三方协力软件)
/boot (开机与核心档)
/var/mail (使用者邮件信箱)

事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：
/ (root, 根目录)：与开机系统有关；
/usr (unix software resource)：与软件安装/执行有关；
/var(variable)：与系统运作过程有关。

root 在Linux 里面的意义真的很多很多～多到让人搞不懂那是啥玩意儿。如果以『账号』的角度来看，所谓的root 指的是『系统管理员！』的身份，如果以『目录』的角度来看，所谓的root 意即指的是根目录，就是/ 啦～要特别留意

FHS标准建议：根目录(/)所在分区槽应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区槽内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题

第一部份：FHS 要求必须要存在的目录
/bin 系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。

/boot 这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等。Linux  kernel常用的档名为：vmlinuz，如果使用的是grub2这个开机管理程序，则还会存在/boot/grub2/这个目录喔！

/dev 在Linux系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的。你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～比要重要的文件有/dev/null,  /dev/zero,  /dev/tty, /dev/loop*, /dev/sd*等等

/etc 系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中喔。比较重要的文件有：/etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等

/lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意

/opt 这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那么也能够将你的软件安装到这里来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下

/run 早期的FHS 规定系统开机后所产生的各项信息应该要放置到/var/run 目录下，新版的FHS 则规范到/run 底下。由于/run 可以使用内存来仿真，因此效能上会好很多

第二部份：FHS 建议可以存在的目录

/home 这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时，默认的用户家目录都
会规范到这里来。比较重要的是，家目录有两种代号喔：~：代表目前这个用户的家目录~dmtsai：则代表dmtsai 的家目录

/root 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区槽中。

很多读者都会误会/usr为user的缩写，其实usr是Unix Software Resource的缩写，也就是『Unix操作系统软件资源』所放置的目录，而不是用户的数据
这个目录有点类似Windows 系统的『C:\Windows\(当中的一部份) + C:\Program files\』这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量


/usr/bin/ 所有一般用户能够使用的指令都放在这里！目前新的CentOS 7 已经将全部的用户指令放置于此，而使用连结档的方式将/bin 连结至此！也就是说，/usr/bin 与/bin 是一模一样了！另外，FHS 要求在此目录下不应该有子目录

因为/var目录主要针对常态性变动的文件，包括快取(cache)、登录档(log file)以及某些软件运作所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有
/var/cache /应用程序本身运作过程中会产生的一些暂存档；
/var/log/ 重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages,  /var/log/wtmp(记录登入者的信息)等。
/var/mail/放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！通常这两个目录是互为链接文件啦！


rmdir：删除一个空的目录
目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他的目录或文件！这也是所谓的空的目录(empty directory)的意思啊！那如果要将所有目录下的东西都删掉呢？！这个时候就必须使用『rm -r test 』

cd是Change Directory的缩写

pwd是Print Working Directory的缩写

想要一个命令可以执行有两种办法
1.将该命令文件的父目录绝对路径加入到PATH中
2.使用该命令文件的绝对路径或相对路径，如果是在命令文件的父目录下也要指定 ./
因为当前目录 . 并没有加入到PATH环境变量中

为什么${PATH} 搜寻的目录不加入本目录(.)？加入本目录的搜寻不是也不错？
答：如果在PATH中加入本目录(.)后，确实我们就能够在指令所在目录进行指令的执行了。但是由于你的工作目录并非固定(常常会使用cd来切换到不同的目录)，因此能够执行的指令会有变动(因为每个目录底下的可执行文件都不相同嘛！)，这对使用者来说并非好事。另外，如果有个坏心使用者在/tmp底下做了一个指令，因为/tmp是大家都能够写入的环境，所以他当然可以这样做。假设该指令可能会窃取用户的一些数据，如果你使用root的身份来执行这个指令，那不是很糟糕？如果这个指令的名称又是经常会被用到的ls时，那『中标』的机率就更高了！
所以，为了安全起见，不建议将『.』加入PATH的搜寻目录中。


不同身份使用者预设的PATH不同，默认能够随意执行的指令也不同
使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH来的正确

ls
-h  ：将文件容量以人类较易读的方式(例如GB, KB 等等)列出来；

rm [-fir] 文件或目录选项与参数：
-f  ：就是force 的意思，忽略不存在的文件，不会出现警告讯息；
-i  ：互动模式，在删除前会询问使用者是否动作
-r  ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！


cat 由第一行开始显示文件内容
tac 从最后一行开始显示，可以看出tac 是cat 的倒着写！
nl 显示的时候，顺道输出行号！
more 一页一页的显示文件内容
less 与more 类似，但是比more 更好的是，他可以往前翻页！
head 只看头几行
tail 只看尾巴几行
od 以二进制的方式读取文件内容！

cat 是Concatenate (连续) 的简写

-n 选项后面的参数较有趣，如果接的是负数，例如上面范例的-n -100时，代表列前的所有行数，但不包括后面100行。
举例来说CentOS 7.1 的/etc/man_db.conf 共有131行，则上述的指
令『head -n -100 /etc/man_db.conf』就会列出前面31行，后面100行不会打印出来了

假如我想要显示/etc/man_db.conf 的第11 到第20 行呢？答：这个应该不算难，想一想，在第11 到第20 行，那么我取前20 行，再取后十行，所以结果就是：
『head -n 20 /etc/man_db.conf | tail -n 10 』，这样就可以得到第11 到第20 行之间的内容了

touch 这个指令最常被使用的情况是：建立一个空的文件；

预设的情况如下：
若使用者建立为『文件』则预设『没有可执行( x )权限』，亦即只有rw 这两个项目，也就是最大为666 分，预设权限如下：-rw-rw-rw-
若用户建立为『目录』，则由于x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为777 分，预设权限如下：drwxrwxrwx

在预设的情况中，root 的umask 会拿掉比较多的属性，root 的umask 默认是022 ，这是基于安全的考虑啦～至于一般身份使用者，通常他们的umask 为002 ，亦即保留同群组的写入权力

which 搜索“命令”
type 这个指令我们可以知道每个指令是否为bash 的内建指令

每个filesystem 都有独立的inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。将文件系统与目录树结合的动作我们称为『挂载』
挂载点一定是目录，该目录为进入该文件系统的入口。因此并不是你有任何文件系统都能使用，必须要『挂载』到目录树的某个目录后，才能够使用该文件系统的

df -h

单一文件系统不应该被重复挂载在不同的挂载点(目录)中；
单一目录不应该重复挂载多个文件系统；
要作为挂载点的目录，理论上应该都是空目录才是

如果你要用来挂载的目录里面并不是空的，那么挂载了文件系统之后，原目录下的东西就会暂时的消失
注意喔！并不是被覆盖掉，而是暂时的隐藏了起来，等到新分区槽被卸除之后，则/home 原本的内容就会再次的跑出来啦


当你使用ls -l 去查询某个目录下的数据时，第一行都会出现一个『total』的字样！那是啥东西？其实那就是该目录下的所有数据所耗用的实际block 数量* block 大小的值


因为Linux 支持的压缩指令非常多，且不同的指令所用的压缩技术并不相同，当然彼此之间可能就无法互通压缩/解压缩文件案啰。所以，当你下载到某个压缩文件时，自然就需要知道该文件是由哪种压缩指令所制作出来的，好用来对照着解压缩啊！也就是说，虽然Linux 文件的属性基本上是与文件名没有绝对关系的，但是为了帮助我们记忆，所以适当的扩展名还是必要的！底下我们就列出几个常见的压缩文件案扩展名吧

*.Z         compress 程序压缩的文件；
*.zip       zip 程序压缩的文件；
.gz        gzip 程序压缩的文件；
*.bz2       bzip2 程序压缩的文件；
*.xz        xz 程序压缩的文件；
*.tar       tar 程序打包的数据，并没有压缩过；
*.tar.gz    tar 程序打包的文件，其中并且经过gzip 的压缩
*.tar.bz2   tar 程序打包的文件，其中并且经过bzip2 的压缩
*.tar.xz    tar 程序打包的文件，其中并且经过xz 的压缩

gzip 可以说是应用度最广的压缩指令

当你使用gzip 进行压缩时，在预设的状态下原本的文件会被压缩成为.gz 的档名，源文件就不再存在了。这点与一般习惯使用windows 做压缩的朋友所熟悉的情况不同喔！要注意！

与gzip 相反，gzip -d 会将原本的.gz 删除，回复到原本的services 文件

zcat/zmore/zless 则可以对应于cat/more/less 的方式来读取纯文本档被压缩后的压缩文件

将原本要转成压缩文件的资料内容，将它变成文字类型从屏幕输出，然后我们可以透过大于(>) 这个符号，将原本应该由屏幕输出的数据，转成输出到文件而不是屏幕

虽然gzip, bzip2, xz 也能够针对目录来进行压缩，不过，这两个指令对目录的压缩指的是『将目录内的所有文件"分别" 进行压缩』的动作

其实最简单的使用tar 就只要记忆底下的方式即可：
压缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查询：tar -jtv -f filename.tar.bz2
解压缩：tar -jxv -f filename.tar.bz2 -C 
欲解压缩的目录那个filename.tar.bz2 是我们自己取的档名，tar 并不会主动的产生建立的档名喔！我们要自定义啦！所以扩展名就显的很重要了！如果不加[-z|-j|-J] 的话，档名最好取为*.tar 即可。如果是-j 选项，代表有bzip2 的支持，因此档名最好就取为*.tar.bz2 ，因为bzip2 会产生.bz2 的扩展名之故！至于如果是加上了-z 的gzip 的支持，那档名最好取为*.tar.gz 


vim 是进阶版的vi ，vim 不但可以用不同颜色显示文字内容，还能够进行诸如shell script, C program 等程序编辑功能，你可以将vim 视为一种程序编辑器

0 或功能键[Home]这是数字『0 』：移动到这一列的最前面字符处(常用)
$ 或功能键[End]移动到这一列的最后面字符处(常用)

/word向光标之下寻找一个名称为word 的字符串。例如要在文件内搜寻vbird 这个字符串，就输入/vbird 即可！(常用)
?word向光标之上寻找一个字符串名称为word 的字符串。

dd删除游标所在的那一整列(常用)
yy复制游标所在的那一列(常用)

当我们在使用vim 编辑时，vim 会在与被编辑的文件的目录下，再建立一个名为.filename.swp 的文件。比如说我们在上一个小节谈到的编辑/tmp/vitest/man_db.conf 这个文件时，vim 会主动的建立/tmp/vitest/.man_db.conf.swp 的暂存档，你对man_db.conf 做的动作就会被记录到这个.man_db.conf.swp 当中喔！如果你的系统因为某些原因断线了，导致你编辑的文件还没有储存，这个时候.man_db.conf.swp 就能够发挥救援的功能了

每个distributions 对vim 的预设环境都不太相同，举例来说，某些版本在搜寻到关键词时并不会高亮度反白，有些版本则会主动的帮你进行缩排的行为。但这些其实都可以自行设定的，那就是vim 的环境设定啰～vim 的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般指令模式时输入『:set all 』来查阅

:set nu:set nonu就是设定与取消行号啊！

其实壳程序的功能只是提供用户操作系统的一个接口，因此这个壳程序需要可以呼叫其他软件才好。我们在第四章到第九章提到过很多指令，包括man, chmod, chown, vi, fdisk, mkfs 等等指令，这些指令都是独立的应用程序，但是我们可以透过壳程序(就是指令列模式) 来操作这些应用程序，让这些应用程序呼叫核心来运作所需的工作

由于早年的Unix 年代，发展者众，所以由于shell 依据发展者的不同就有许多的版本，例如常听到的Bourne SHell (sh) 、在Sun 里头预设的C SHell、商业上常用的K SHell、, 还有TCSH 等等，每一种Shell 都各有其特点。至于Linux 使用的这一种版本就称为『Bourne Again SHell (简称bash)』，这个Shell 是Bourne Shell 的增强版本，也是基准于GNU 的架构下发展出来的

第一个流行的shell 是由Steven Bourne 发展出来的，为了纪念他所以就称为Bourne shell ，或直接简称为sh


[ctrl]+u/[ctrl]+k分别是从光标处向前删除指令串([ctrl]+u) 及向后删除指令串([ctrl]+k)。
[ctrl]+a/[ctrl]+e分别是让光标移动到整个指令串的最前面([ctrl]+a) 或最后面([ctrl]+e)。

变量的取用就如同上面的范例，利用echo 就能够读出，只是需要在变量名称前面加上$ ，或者是以${变量} 的方式来取用都可以

请在屏幕上面显示出您的环境变量HOME 与MAIL：
答：echo $HOME 或者是echo ${HOME}echo $MAIL 或者是echo ${MAIL}



变量的设定规则

set命令作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值和属性。使用set更改shell特性时，符号"+"和"-"的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用declare命令以变量名=值的格式进行定义即可。

1.变量与变量内容以一个等号『=』来连结，如下所示：『myname=VBird』
2.等号两边不能直接接空格符，如下所示为错误：『myname = VBird』或『myname=VBird Tsai』
3.变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误：『2myname=VBird』
4.变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来，但o双引号内的特殊字符如$ 等，可以保有原本的特性，
如下所示：『var="lang is $LANG"』则『echo $var』可得『lang is zh_TW.UTF-8』o单引号内的特殊字符则仅为一般字符(纯文本)，
如下所示：『var='lang is $LANG'』则『echo $var』可得『lang is $LANG』
7.若该变量为扩增变量内容时，则可用"$变量名称" 或${变量} 累加内容，如下所示：『PATH="$PATH":/home/bin』或『PATH=${PATH}:/home/bin』
8.若该变量需要在其他子程序执行，则需要以export 来使变量变成环境变量：『export PATH』
10.取消变量的方法为使用unset：『unset 变量名称』例如取消myname 的设定：『unset myname』

子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量啦！所以你在原本bash 的自定义变量在进入了子程序后就会消失不见，一直到你离开子程序并回到原本的父程序后，这个变量才会又出现

有父程序与子程序的不同程序关系时，则『变量』可否被引用与export 有关。被export 后的变量，我们可以称他为『环境变量』！环境变量可以被子程序所引用，但是其他的自定义变量内容就不会存在于子程序中

变量设定方式说明${变量#关键词}${变量##关键词}若变量内容从头开始的数据符合『关键词』，则将符合的最短数据删除若变量内容从头开始的数据符合『关键词』，则将符合的最长数据删除${变量%关键词}${变量%%关键词}若变量内容从尾向前的数据符合『关键词』，则将符合的最短数据删除若变量内容从尾向前的数据符合『关键词』，则将符合的最长数据删除${变量/旧字符串/新字符串}${变量//旧字符串/新字符串}若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串取代』若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代』

alias 的定义规则与变量定义规则几乎相同』，所以你只要在alias 后面加上你的{『别名』='指令选项...'}


alias lm='ls -al | more'
unalias lm

查看指令历史 history

可以直接以『!! 』来下达上个指令的内容，此外，我也可以直接选择下达第n 个指令，『!n 』来执行，也可以使用指令标头，例如『!vi 』来执行最近指令开头是vi 的指令列

命令别名、自定义的变量，在你注销bash后就会失效，所以你想要保留你的设定，就得要将这些设定写入配置文件才行

1./etc/profile：这是系统整体的设定，你最好不要修改这个文件；
2.~/.bash_profile 或~/.bash_login 或~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里

1.~/.bash_profile
2.~/.bash_login
3.~/.profile
其实bash 的login shell 设定只会读取上面三个文件的其中一个，而读取的顺序则是依照上面的顺序


由于/etc/profile 与~/.bash_profile 都是在取得login shell 的时候才会读取的配置文件，所以，如果你将自己的偏好设定写入上述的文件后，通常都是得注销再登入后，该设定才会生效。那么，能不能直接读取配置文件而不注销登入呢？可以的！那就得要利用source 这个指令了

Ctrl + C终止目前的命令
Ctrl + D输入结束(EOF)，例如邮件结束的时候；
Ctrl + M就是Enter 啦！
Ctrl + S暂停屏幕的输出
Ctrl + Q恢复屏幕的输出
Ctrl + U在提示字符下，将整列命令删除
Ctrl + Z『暂停』目前的命令

*代表『0 个到无穷多个』任意字符
?代表『一定有一个』任意字符
[ ]同样代表『一定有一个在括号内』的字符(非任意字符)。例如[abcd] 代表『一定有一个字符，可能是a, b, c, d 这四个任何一个』
[ -]若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如[0-9] 代表0 到9 之间的所有数字，因为数字的语系编码是连续的！
[^ ]若中括号内的第一个字符为指数符号(^) ，那表示『反向选择』，例如[^abc] 代表一定有一个字符，只要是非a, b, c 的其他字符就接受的意思

# 批注符号：这个最常被使用在script 当中，视为说明，在后的数据均不执行
\ 跳脱符号：将『特殊字符或通配符』还原成一般字符
| 管线(pipe)：分隔两个管线命令的界定(后两节介绍)；
; 连续指令下达分隔符：连续性命令的界定(注意！与管线命令并不相同)
~ 用户的家目录$取用变数前导符：亦即是变量之前需要加的变量取代值
& 工作控制(job control)：将指令变成背景下工作!逻辑运算意义上的『非』not 的意思！
/ 目录符号：路径分隔的符号
>, >> 数据流重导向：输出导向，分别是『取代』与『累加』
<, << 数据流重导向：输入导向(这两个留待下节介绍)
' ' 单引号，不具有变量置换的功能($ 变为纯文本)
" " 具有变量置换的功能！($ 可保留相关功能)
` ` 两个『` 』中间为可以先执行的指令，亦可使用$( )
( ) 在中间为子shell 的起始与结束
{ } 在中间为命令区块的组合！

数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给他传输到其他的地方，例如文件或者是装置(例如打印机之类的)！这玩意儿在Linux 的文本模式底下可重要的！尤其是如果我们想要将某些数据储存下来时，就更有用了

也就是若以> 输出到一个已存在的文件中，那个文件就会被覆盖掉
想要将数据累加而不想要将旧的数据删除，利用两个大于的符号(>>) 就好

1.标准输入(stdin) ：代码为0 ，使用< 或<< ；
2.标准输出(stdout)：代码为1 ，使用> 或>> ；
3.标准错误输出(stderr)：代码为2 ，使用2> 或2>> ；

< 将原本需要由键盘输入的数据，改由文件内容来取代


在指令与指令中间利用分号(;) 来隔开，这样一来，分号前的指令执行完后就会立刻接着执行后面的指令了


cmd1 && cmd2
1. 若cmd1 执行完毕且正确执行($?=0)，则开始执行cmd2。
2. 若cmd1 执行完毕且为错误($?≠0)，则cmd2 不执行。
cmd1 || cmd2
1. 若cmd1 执行完毕且正确执行($?=0)，则cmd2 不执行。
2. 若cmd1 执行完毕且为错误($?≠0)，则开始执行cmd2。

管线命令『| 』
其实这个管线命令『| 』仅能处理经由前面一个指令传来的正确信息，也就是standard output 的信息，对于stdandard error 并没有直接处理的能力


在每个管线后面接的第一个数据必定是『指令』喔！而且这个指令必须要能够接受standard input 的数据才行，这样的指令才可以是为『管线命令』，例如less, more, head, tail 等都是可以接受standard input 的管线命令啦。至于例如ls, cp, mv 等就不是管线命令了！因为ls, cp, mv 并不会接受来自stdin 的数据。也就是说，管线命令主要有两个比较需要注意的地方：
管线命令仅会处理standard output，对于standard error output 会予以忽略
管线命令必须要能够接受来自前一个指令的数据成为standard input 继续处理才行

撷取命令：cut, grep

cut -d'分隔字符' -f fields

cut 主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文字数据的时候！这是因为有时候我们会以某些字符当作分区的参数，然后来将数据加以切割，以取得我们所需要的数据

cut 是将一行讯息当中，取出某部分我们想要的，而grep 则是分析一行讯息，若当中有我们所需要的信息，就将该行拿出来

grep [-acinv] [--color=auto] '搜寻字符串' filename

grep可以直接用来查询文件中包含关键字的行，不是必须要用在管道命令中
默认情况下，grep是区分大小写的

-i：在搜索的时候忽略大小写
-n：显示结果所在行号
-c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数
-o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行
-v：输出不带关键字的行（反向查询，反向匹配）
-Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after
-Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before


sort排序
uniq去重
wc字数行数统计

字符转换命令：tr, col, join, paste, expand

tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换

环境变量用env 或export 而所有变量用set 即可显示


vi, grep, awk ,sed 等等工具，因为她们有支持正规表示法，所以，这些工具就可以使用正规表示法的特殊字符来进行字符串的处理。但例如cp, ls 等指令并未支持正规表示法，所以就只能使用bash 自己本身的通配符而已

『正规表示法与通配符是完全不一样的东西！』这很重要喔！因为『通配符(wildcard) 代表的是bash 操作接口的一个功能』，但正规表示法则是一种字符串处理的表示方式！这两者要分的很清楚才行

grep 在数据中查寻一个字符串时，是以"整行" 为单位来进行数据的撷取的！

awk 主要是处理『每一行的字段内的数据』，而默认的『字段的分隔符为"空格键" 或"[tab]键" 』！

整个awk 的处理流程是：1.读入第一行，并将第一行的资料填入$0, $1, $2.... 等变数当中；2.依据"条件类型" 的限制，判断是否需要进行后面的"动作"；3.做完所有的动作与条件类型；4.若还有后续的『行』的数据，则重复上面1~3 的步骤，直到所有的数据都读完为止


diff 就是用在比对两个文件之间的差异的，并且是以行为单位来比对的！一般是用在ASCII 纯文本档的比对上

shell script

1.指令的执行是从上而下、从左而右的分析与执行；
2.指令的下达就如同第四章内提到的：指令、选项与参数间的多个空白都会被忽略掉；
3.空白行也将被忽略掉，并且[tab] 按键所推开的空白同样视为空格键；
4.如果读取到一个Enter 符号(CR) ，就尝试开始执行该行(或该串) 命令；
5.至于如果一行的内容太多，则可以使用『\[Enter] 』来延伸至下一行；
6.『# 』可做为批注！任何加在# 后面的资料将全部被视为批注文字而被忽略！

直接指令下达：shell.sh 文件必须要具备可读与可执行(rx) 的权限，然后：
绝对路径：使用/home/dmtsai/shell.sh 来下达指令；
相对路径：假设工作目录在/home/dmtsai/ ，则使用./shell.sh 来执行
变量『PATH』功能：将shell.sh 放在PATH 指定的目录内，例如：~/bin/
以bash 程序来执行：透过『bash shell.sh 』或『sh shell.sh 』来执行

由于CentOS 默认用户家目录下的~/bin 目录会被设定到${PATH} 内，所以你也可以将shell.sh 建立在/home/dmtsai/bin/ 底下( ~/bin 目录需要自行设定) 。此时，若shell.sh 在~/bin 内且具有rx 的权限，那就直接输入shell.sh 即可执行该脚本程序

script 的执行方式差异(source, sh script, ./script)

当使用前一小节提到的直接指令下达(不论是绝对路径/相对路径还是${PATH} 内)，或者是利用bash (或sh) 来下达脚本时，该script 都会使用一个新的bash 环境来执行脚本内的指令！也就是说，使用这种执行方式时，其实script 是在子程序的bash 内执行的

当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中

test -e /dmtsai && echo "exist" || echo "Not exist

-e该『档名』是否存在？(常用)
-f该『档名』是否存在且为文件(file)？(常用)
-d该『文件名』是否存在且为目录(directory)？(常用)

test -z string判定字符串是否为0 ？若string 为空字符串，则为true
test -n string判定字符串是否为非0 ？若string 为空字符串，则为false。注：-n 亦可省略

除了我们很喜欢使用的test 之外，其实，我们还可以利用判断符号『[ ] 』(就是中括号啦) 来进行数据的判断
使用中括号必须要特别注意，因为中括号用在很多地方，包括通配符与正规表示法等等，所以如果要在bash 的语法当中使用中括号作为shell 的判断式时，必须要注意中括号的两端需要有空格符来分隔

上面的判断式当中使用了两个等号『== 』。其实在bash 当中使用一
个等号与两个等号的结果是一样的！不过在一般惯用程序的写法中，一个等号代表『变量的设定』，两个等号则是代表『逻辑判断(是与否之意)』。由于我们在中括号内重点在于『判断』而非『设定变量』，因此建议您还是使用两个等号较佳

连续命令中，;, &&, || 有何不同？
分号可以让两个command 连续运作，不考虑command1 的输出状态，
&& 则前一个指令必需要没有错误讯息，亦即回传值需为0 则command2 才会被执行，
|| 则与&& 相反
shell脚本中不会使用分号作为语句结束符而是使用换行，分号一般用在if和for语句条件后

如果ifelse后只有单个命令则可以不使用ifelse，直接使用&&, ||连接命令即可
在ifelse判断条件语句中也可以使用&&, ||连接，表示and or的意思 或者使用 -o 连接表示或的意思
另外在判断变量是否等于某字符串时，请在变量外加引号，如：
${PATH} == "/bin" 错误
"${PATH}" == "/bin" 正确

通配符
如何秀出在/bin 底下任何以a 为开头的文件文件名的详细资料？
ls -ld /bin/a*
如何秀出/bin 底下，文件名为四个字符的文件？
ls -ld /bin/????
如何秀出/bin 底下，档名开头不是a-d 的文件？
ls -ld /bin/[^a-d]*

请问foo1 && foo2 | foo3 > foo4 ，这个指令串当中，foo1/foo2/foo3/foo4 是指令还是文件？
整串指令的意义为？foo1, foo2 与foo3 都是指令，foo4 是装置或文件。整串指令意义为：
(1)当foo1 执行结果有错误时，则该指令串结束；
(2)若foo1 执行结果没有错误时，则执行foo2 | foo3 > foo4 ；其中：
(2-1)foo2 将stdout 输出的结果传给foo3 处理；
(2-2)foo3 将来自foo2 的stdout 当成stdin ，处理完后将数据流重新导向foo4 这个装置/文件

/path/to/scriptname  opt1  opt2  opt3  opt4
		$0             $1    $2    $3    $4

执行的脚本档名为$0 这个变量，第一个接的参数就是$1
$# ：代表后接的参数『个数』，以上表为例这里显示为『4 』；
$@ ：代表『"$1" "$2" "$3" "$4" 』之意，每个变量是独立的(用双引号括起来)；
$* ：代表『"$1c$2c$3c$4" 』，其中c为分隔字符，默认为空格键，所以本例中代表『"$1 $2 $3 $4" 』之意。

if [条件判断式一]; then
		当条件判断式一成立时，可以进行的指令工作内容；
elif [条件判断式二]; then
		当条件判断式二成立时，可以进行的指令工作内容；
else
		当条件判断式一与二均不成立时，可以进行的指令工作内容；
fi

IP的部分说明的是该服务位于那个接口上，若为127.0.0.1 则是仅针对本机开放，若是0.0.0.0 或::: 则代表对整个Internet 开放(更多信息请参考服务器架设篇的介绍)。每个埠口(port) 都有其特定的网络服务，几个常见的port 与相关网络服务的关系是：
80: WWW
22: ssh
21: ftp
25: mail
111: RPC(远程过程调用)
631: CUPS(打印服务功能)

case  $变量名称 in      
	"第一个变量内容")
		程序段
		;;
	"第二个变量内容")
		程序段
		;;
	*)
		exit 1
		;;
esac

因为shell script 的执行方式是由上而下，由左而右，因此在shell script 当中的function 的设定一定要在程序的最前面，这样才能够在执行时被找到可用的程序段喔(这一点与传统程序语言差异相当大！初次接触的朋友要小心
function 也是拥有内建变量的～他的内建变量与shell script 很类似，函数名称代表示$0 ，而后续接的变量也是以$1, $2... 来取代的～这里很容易搞错喔～因为『function fname() { 程序段} 』内的$0, $1... 等等与shell script 的$0 是不同的。以上面show123-2.sh 来说，假如我下达：『sh show123-2.sh one 』这表示在shell script 内的$1 为"one" 这个字符串。但是在printit() 内的$1 则与这个one 无关

while do done, until do done (不定循环)
while [ "${yn}" != "yes" -a "${yn}" != "YES" ]
do
	read -p "Please input yes/YES to stop this program: " yn
done

for var in con1 con2 con3 ... 
do
	程序段
done


for ((初始值;限制值;执行步阶))
do
	程序段
done

sh [-nvx] scripts.sh选项与参数：
-n  ：不要执行script，仅查询语法的问题；
-v  ：再执行sccript 前，先将scripts 的内容输出到屏幕上；
-x  ：将使用到的script 内容显示到屏幕上，这是很有用的参数！

shell script 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上，就不够好了，因为Shell scripts 的速度较慢，且使用的CPU 
资源较多，造成主机资源的分配不良

良好的程序撰写习惯中，第一行要宣告shell (#!/bin/bash) ，第二行以后则宣告程序用途、版本、作者等

使用useradd 建立了账号之后，在预设的情况下，该账号是暂时被封锁的，也就是说，该账号是无法登入的，需要设置新密码后才能使用
要帮一般账号建立密码需要使用『passwd 账号』的格式，使用『passwd 』表示修改自己的密码

单纯使用『su 』切换成为root 的身份，读取的变量设定方式为non-login shell 的方式，这种方式很多原本的变量不会被改变，尤其是我们之前谈过很多次的PATH 这个变量，由于没有改变成为root 的环境，因此很多root 惯用的指令就只能使用绝对路径来执行

su -
让使用者的身份变成root 并开始操作系统，如果想要离开root 的身份则得要利用exit 离开

相对于su 需要了解新切换的用户密码(常常是需要root 的密码)，sudo 的执行则仅需要自己的密码即可

并非所有人都能够执行sudo ，而是仅有规范到/etc/sudoers 内的用户才能够执行sudo 这个指令
sudo也不是可以执行所有root的命令，sudo可以执行的命令也是可配置的

两次执行sudo 的间隔在五分钟内，那么再次执行sudo 时就不需要再次输入密码了

由于指令的下达与PATH 变量有关，同时与当时的工作目录也有关连(如果有牵涉到文件的话)，因此使用绝对路径来下达指令，会是比较一劳永逸的方法

我的dmtsai 账号同时支持dmtsai, wheel 与users 这三个群组，因此，在读取/写入/执行文件时，针对群组部分，只要是users, wheel 与dmtsai 这三个群组拥有的功能，我dmtsai 这个使用者都能够拥有

groups命令查看当前用户所有群组，其中一个为当前有效群组，当创建文件时，被创建的文件所属的就是当前有效群组

newgrp: 有效群组的切换

不同的使用者身份执行这个program 时，系统给予的权限也都不相同！

程序一般是放置在实体磁盘中，然后透过用户的执行来触发。触发后会加载到内存中成为一个个体，那就是进程。为了操作系统可管理这个进程，因此进程有给予执行者的权限/属性等参数，并包括程序所需要的脚本与数据或文件数据等，最后再给予一个PID 。系统就是透过这个PID 来判断该process 是否具有权限进行工作的

我们要操作系统的时候，通常是利用联机程序或者直接在主机前面登入，然后取得我们的shell ！那么，我们的shell 是bash ，这个bash 在/bin/bash ，那么同时间的每个人登入都是执行/bin/bash ！不过，每个人取得的权限就是不同

我们知道/bin/bash 是一个程序(program)，当dmtsai 登入后，他取得一个PID 号码为2234 的进程，这个进程的User/Group 都是dmtsai ，而当这个程序进行其他作业时，例如上面提到的touch 这个指令时，那么由这个进程衍生出来的其他进程在一般状态下，也会沿用这个进程的相关权限的

当我们登入系统后，会取得一个bash 的shell ，然后，我们用这个bash 提供的接口去执行另一个指令，例如/usr/bin/passwd 或者是touch 等等，那些另外执行的指令也会被触发成为PID ，呵呵！那个后来执行指令才产生的PID 就是『子进程』了，而在我们原本的bash 环境下，就称为『父进程』了

在Linux 的进程呼叫通常称为fork-and-exec 的流程(注1)！进程都会藉由父进程以复制(fork) 的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec 的方式来执行实际要进行的程序，最终就成为一个子进程的存在。

如果就我们之前学到的一些指令数据来看，其实我们下达的指令都很简单，包括用ls 显示文件啊、用touch 建立文件啊、rm/mkdir/cp/mv 等指令管理文件啊、chmod/chown/passwd 等等的指令来管理权限等等的，不过，这些指令都是执行完就结束了。也就是说，该项指令被触发后所产生的PID 很快就会终止呢！那有没有一直在执行的进程啊？当然有啊！而且多的是呢

Linux 希望我们可以简单的判断该程序是否为daemon，所以，一般daemon 类型的程序都会加上d 在文件名后头～包括服务器篇我们会看到的httpd, vsftpd 等等都是

Linux 几乎可以说绝对不会当机的！因为他可以在任何时候，将某个被困住的进程杀掉，然后再重新执行该进程而不用重新启动！

那么如果我在Linux 下以文字界面登入，在屏幕当中显示错误讯息后就挂了～动都不能动，该如何是好！？这个时候那默认的七个窗口就帮上忙啦！你可以随意的再按[Alt]+[F1].....[F7] 来切换到其他的终端机界面，然后以ps -aux找出刚刚的错误进程，然后给他kill一下，回到刚刚的终端机界面！恩～棒！又回复正常啰

cp file1 file2 &
在这一串指令中，重点在那个& 的功能，他表示将file1 这个文件复制为file2 ，且放置于背景中执行，也就是说执行这一个命令之后，在这一个终端接口仍然可以做其他的工作！而当这一个指令(cp file1 file2) 执行完毕之后，系统将会在你的终端接口显示完成的消息

那个+ 代表最近一个被丢进背景的工作，且目前在背景下预设会被取用的那个工作(与fg 这个指令有关)！而那个Stopped 则代表目前这个工作的状态。在预设的情况下，使用[ctrl]-z 丢到背景当中的工作都是『暂停』的状态喔

将背景工作拿到前景来处理：fg

找出目前的bash 环境下的背景工作 jobs

kill 选项与参数
：-l  ：这个是L 的小写，列出目前kill 能够使用的讯号(signal) 有哪些？
signal ：代表给予后面接的那个工作什么样的指示啰！用man 7 signal 可知：
-1 ：重新读取一次参数的配置文件(类似reload)；
-2 ：代表与由键盘输入[ctrl]-c 同样的动作；
-9 ：立刻强制删除一个工作；
-15：以正常的进程方式终止一项工作。与-9 是不一样的。

-9 这个signal 通常是用在『强制删除一个不正常的工作』时所使用的，-15 则是以正常步骤结束一项工作(15也是默认值)，两者之间并不相同呦！举上面的例子来说，我用vim 的时候，不是会产生一个.filename.swp 的文件吗？那么，当使用-15 这个signal 时，vim 会尝试以正常的步骤来结束掉该vi 的工作，所以.filename.swp 会主动的被移除。但若是使用-9 这个signal 时，由于该vim 工作会被强制移除掉，因此，.filename.swp 就会继续存在文件系统当中

要注意的是，我们在工作管理当中提到的『背景』指的是在终端机模式下可以避免[crtl]-c 中断的一个情境，你可以说那个是bash 的背景，并不是放到系统的背景去喔
在工作尚未结束的情况下你脱机了，该工作还会继续进行吗？答案是『否』！不会继续进行，而是会被中断掉

at 是将工作放置到系统背景，而与终端机无关。如果不想要使用at 的话，那你也可以尝试使用nohup 这个指令来处理喔！这个nohup 可以让你在脱机或注销系统后，还能够让工作继续进行

建议你，直接背两个比较不同的选项，一个是只能查阅自己bash 进程的『ps -l 』一个则是可以查阅所有系统运作的进程『ps aux 』！注意，你没看错，是『ps aux 』没有那个减号(-)

STAT ：代表这个进程的状态(STAT)，主要的状态有：
R (Running)：该程序正在运作中；
S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。
D ：不可被唤醒的睡眠状态，通常这支程序可能在等待I/O 的情况(ex>打印)
T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错(traced) 状态；
Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外

通常，造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了，但是该进程的父进程却无法完整的将该进程结束掉，而造成那个进程一直存在内存当中。如果你发现在某个进程的CMD 后面还接上<defunct> 时，就代表该进程是僵尸进程

相对于ps 是撷取一个时间点的进程状态，top 则可以持续侦测进程运作的状态

top 预设使用CPU 使用率(%CPU) 作为排序的重点，如果你想要使用内存使用率排序，则可以按下『M』，若要回复则按下『P』即可。如果想要离开top 则按下『q 』吧

如果要找进程之间的相关性，这个pstree 真是好用到不行！直接输入pstree 可以查到进程相关性

由于kill 后面必须要加上PID (或者是job number)，所以，通常kill 都会配合ps,pstree等指令，因为我们必须要找到相对应的那个进程的ID 嘛！但是，如此一来，很麻烦～有没有可以利用『下达指令的名称』来给予讯号的？举例来说，能不能直接将rsyslogd 这个进程给予一个SIGHUP 的讯号呢？可以的！用killall 吧

killall [-iIe] [command name]
选项与参数：
-i  ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户；
-e  ：exact 的意思，表示『后面接的command name 要一致』，但整个完整的指令不能超过15 个字符。
-I  ：指令名称(可能含参数)忽略大小写

free ：观察内存使用情况
uname：查阅系统与核心相关信息
netstat ：追踪网络或插槽文件


root 是可以在系统上面进行任何事情的，所有的权限控制都对root无效

chattr +a /var/log/admin.log
加入了这个属性之后，你的/var/log/admin.log 登录档从此就仅能被增加，而不能被删除，直到root 以『chattr -a /var/log/admin.log 』取消这个a 的参数之后，才能被删除或移动

Linux 上面的软件几乎都是经过GPL 的授权，所以每个软件几乎均提供源代码，并且你可以自行修改该程序代码，以符合你个人的需求
Linux 系统上真正认识的可执行文件其实是二进制文件( binary program)，所有的命令都是呼叫二进制文件执行的

或许你会说shell scripts 不是也可以执行吗？其实shell scripts 只是利用shell (例如bash) 这支程序的功能进行一些判断式，而最终执行的除了bash 提供的功能外，仍是呼叫一些已经编译好的二进制程序来执行的呢！当然啦，bash 本身也是一支二进制程序

因为你的scripts 上面第一行有宣告#!/bin/bash 的缘故，如果你将script 的第一行拿掉，那么不管/etc/init.d/network 的权限为何，他其实显示的是ASCII 文本文件的信息

gcc 为Linux 上面最标准的编译程序，这个gcc 是由GNU 计划所维护的

C 语言的程序代码在各个平台上面是可以共通的，只是需要的编译程序可能并不相同而已。例如Linux 上面用gcc 而Windows 上面也有相关的C 编译程序啊～所以呢，同样的一组原始码，既可以在CentOS Linux 上面编译，也可以在SuSE Linux 上面编译，当然，也可以在大部分的Unix 平台上面编译成功的

我们在Linux 底下写的程序『理论上，是可以在Windows 上面编译的！』

以原始码的方式来安装软件，也就是利用厂商释出的Tarball 来进行软件的安装。不过，你应该很容易发现，那就是每次安装软件都需要侦测操作系统与环境、设定编译参数、实际的编译、最后还要依据个人喜好的方式来安装软件到定位。这过程是真的很麻烦

厂商先在他们的系统上面编译好了我们用户所需要的软件，然后将这个编译好的可执行的软件直接释出给用户来安装

RPM 全名是『RedHat Package Manager』简称则为RPM 啦！顾名思义，当初这个软件管理的机制是由Red Hat 这家公司发展出来的。RPM 是以一种数据库记录的方式来将你所需要的软件安装到你的Linux 系统的一套管理机制

 RPM 属性相依的克服方式：YUM 在线升级

 查询功能：yum [list|info|search|provides|whatprovides] 参数

 安装/升级功能：yum [install|update] 软件

 移除功能：yum [remove] 软件

 1.安装：yum install (你的软件)
 2.启动：systemctl start (你的软件)
 3.开机启动：systemctl enable (你的软件)
 4.防火墙：firewall-cmd --add-service="(你的服务)"; firewall-cmd --permanent --add-service="(你的服务)"
 5.测试：用软件去查阅你的服务正常与否～

停止tomcat：cd /usr/local/tomcat8080/bin 然后 sh shutdown.sh

启动tomcat：cd /usr/local/tomcat8080/bin 然后 sh startup.sh
