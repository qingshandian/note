随笔
状态机
状态机组成：a实体，在b状态下，由c角色，在满足d条件时，执行e操作成功后，迁移到f状态下，并产生g事件

适用于目标状态繁多、用状态控制代码逻辑比较复杂的系统

不使用状态机，正常的状态流转处理方式：
1.使用大量的ifelse对不同的状态控制走不同的流程，
2.获取一个状态的下一个状态以及每个状态可接受的操作都通过代码逻辑控制
3.每个修改状态的接口都需要校验当前状态（对一个流程进行审核之前要先判断下当前状态是否是未审核状态）
4.大量的状态逻辑判断代码分散在各个接口中，维护性和扩展性差

状态机基本思想：使用配置数据替代硬编码逻辑

使用状态机的优点：
1.把所有的状态逻辑代码都使用状态机实现，避免了很多很重的判定逻辑分散在程序各地，且流程可配置化，高内聚，可维护性、扩展性强
2.接口中无需校验当前状态，状态机不允许对某个状态进行错误的操作
3.获取下一个状态以及产生的事件非常方便，大量的ifelse代码不再需要，调用方不需要关心各个状态具体的流转过程


dubbo
RPC(Remote Procedure Call)远程过程调用

为什么需要RPC？软件应用体量的日益庞大，开发维护越来越困难，出于解耦和便于管理的思想将单个应用按业务或者功能性拆分成多个子应用，多个子应用之间的调用非常频繁，http的restful调用已经不适合，所以出现了RPC，远程调用功能开发更方便，性能更高

将单体系统剥离、引入服务化组件、将内部调用转化为远程调用、解决因为调用远程化和分布化而带来的各种次生问题（网络问题、安全问题、状态管理问题、一致性问题等等）

RPC两个核心：1.像调用本地方法一样调用远程服务 2.定制化的应用层协议

对接异构第三方服务时，通常使用 HTPP/RESTful 等公有协议，对于内部的服务调用，应用选择性能更高的二进制私有协议

RPC最本质的就是通过socket把方法信息传输到远程服务器并执行相应method

在java界的rpc框架的实现手法：
服务端：socket + 反射
客户端：动态代理 + socket


对于有状态的服务器（包含数据存储的）在集群中必然存在数据一致性的问题，在网络出现分区时若要保证高一致性，则将部分网络分区的服务器丢弃置为不可用，结果是导致可用性的降低（zk脑裂），
若要保证高可用性，所有服务器仍然都可用，但彼此之间的数据不再进行同步（分区结束后重新同步保证最终一致性）结果是一致性的降低

由单体应用进化到服务化拆分部署，后期随着移动互联网规模的不断扩大，敏捷开发、持续交付、DevOps 理论的发展和实践，以及基于 Docker 容器化技术的成熟，微服务架构开始流行，逐渐成为应用架构的未来演进方向。

总结来说，微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付的周期，并被各大互联网公司所普遍采用。



APM


分析之前先理清楚几个概念

Log4J = Log For Java

SLF4J = Simple Logging Facade for Java
看到Facade首先想到的就是设计模式中的门面（Facade）模式，实际上SLF4J 就是一个装"门面"的java日志框架，它只提供一层抽象且通用的日志API供调用方写日志使用，而真正实现写日志功能的则是Log4J、logback等框架和从jdk1.4之后开始提供的java.util.logging包，而具体要使用谁就要看SLF4J中设置的策略，整体来看的话也确实是使用了门面模式
关于这几个日志框架的诞生和关系推荐看下这篇博客：https://blog.csdn.net/qq_32625839/article/details/80893550


Apache的commons-logging和SLF4J 一样，也是一个抽象的日志框架，使用的更广泛，下面通过几段源码分析下其内部的门面模式是怎样实现的
一般写日志之前都要先下面的方法获取到log对象

Log log = LogFactory.getLog(clz.getName());

进入getLog方法




    private Log discoverLogImplementation(String logCategory)
        throws LogConfigurationException {


            private static final String[] classesToDiscover = {
            "org.apache.commons.logging.impl.Log4JLogger",
            "org.apache.commons.logging.impl.Jdk14Logger",
            "org.apache.commons.logging.impl.Jdk13LumberjackLogger",
            "org.apache.commons.logging.impl.SimpleLog"
            }



早期绑定(静态绑定)  编译器生成对特定函数名的调用，该调用会被解析为将执行的代码的绝对地址           
后期绑定（动态绑定） 当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码

为了执行后期绑定，Java 使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址，因此，每个对象的行为根据特定代码位的内容而不同。当你向对象发送消息时，对象知道该如何处理这条消息。C++ 使用virtual关键字。在这些语言中，默认情况下方法不是动态绑定的。在 Java 中，动态绑定是默认行为，不需要额外的关键字来实现多态性。


在 Java 5 泛型出来之前，集合中保存的是通用类型 Object。Java 单继承的结构意味着所有元素都基于 Object 类，所以在集合中可以保存任何类型的数据，易于重用。要使用这样的集合，我们先要往集合添加元素。由于 Java 5 版本前的集合只保存 Object，当我们往集合中添加元素时，元素便向上转型成了 Object，从而丢失自己原有的类型特性。这时我们再从集合中取出该元素时，元素的类型变成了 Object。那么我们该怎么将其转回原先具体的类型呢？这里，我们使用了强制类型转换将其转为更具体的类型，这个过程称为对象的“向下转型”

每次取出元素都要做额外的“向下转型”对程序和程序员都是一种开销。以某种方式创建集合，以确认保存元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误难道不好吗？这种解决方案就是：参数化类型机制（Parameterized Type Mechanism）

面向对象编程可以总结为：向对象发送消息

&&短路功能 &没有

在JDK1.5以后，classpath并不是必须配置了，在JDK1.5之前，是没有办法在当前目录下加载类的（找不到 JDK目录下lib文件夹中的.jar文件），所以我们需要通过配置classpath，但JDK1.5之后，JRE能自动搜索目录下类文件，并且加载dt.jar和tool.jar的类。

JAVA_HOME = C:\java\jdk1.8.0_131
PATH = $JAVA_HOME\bin

.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 注意 . 代表的是当前目录
1.rt.jar 
rt.jar是JAVA基础类库，也就是你在java doc里面看到的所有的类的class文件
默认就在Root Classloader的加载路径里面的，而在Claspath配置该变量是不需要的；同时jre/lib目录下的
其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar都在Root Classloader中

2.tools.jar 
是系统用来编译一个类的时候用到的，即执行javac的时候用到
javac XXX.java实际上就是运行
java -Classpath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java
javac就是对上面命令的封装 所以tools.jar 也不用加到classpath里面

3. dt.jar
dt.jar是关于运行环境的类库,主要是swing的包   在用到swing时最好加上。

编译过的代码通常位于与源代码的不同目录中。这是很多工程的标准，而且集成开发环境（IDE）通常会自动为我们做这些。必须保证 JVM 通过 CLASSPATH 能找到编译后的代码。

不要错误地认为 Java 总是会将当前目录视作查找行为的起点之一。如果你的 CLASSPATH 中没有 .，Java 就不会查找单独当前目录

每个编译单元（即每个文件）中只能有一个 public 类。这表示，每个编译单元有一个公共的接口用 public 类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的 public 类，编译就会报错。
public 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以对于 Widget 来说，文件名必须是 Widget.java，不能是 widget.java 或 WIDGET.java。再次强调，如果名字不匹配，编译器会报错。
虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。

构造代码块
直接在类中定义且没有加static关键字的代码块称为{}构造代码块。
构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。
这个构造代码块的执行顺序不会因为方法所在位置而影响

组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）
“是一个”的关系是用继承来表达的，而“有一个“的关系则用组合来表达

Java 没有提供将任意对象设为常量的方法

构造器也是一个 static 方法尽管它的 static 关键字是隐式的。因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。
构造方法虽然是static的，但是可以调用非static的方法
private 方法也是隐式的 final

只有普通的方法调用可以是多态的。例如，如果你直接访问一个属性，该访问会在编译时解析

那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。
所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。




对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。

匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。

实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 x 和 i 必须被明确声明为 final。在 Java 8 中，内部类的规则放宽，包括等同 final 效果。

所有的类都是第一次使用时动态加载到 JVM 中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类。

其实构造器也是类的静态方法，虽然构造器前面并没有 static 关键字。所以，使用 new 操作符创建类的新对象，这个操作也算作对类的静态成员引用。

RTTI（RunTime Type Information，运行时类型信息）

Java 程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加载。这一点与许多传统编程语言不同，动态加载使得 Java 具有一些静态加载语言（如 C++）很难或者根本不可能实现的特性。

注意，有一点很有趣：当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该Class 对象。为了使用类而做的准备工作实际包含三个步骤：
1.加载，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个 Class 对象。
2.链接。在链接阶段将验证类中的字节码，为 static 域分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用。
3.初始化。如果该类具有超类，则对其进行初始化，执行 static 初始化器和 static 初始化块。
初始化被延迟到了对 static 方法（构造器隐式地是 static 的）或者非常数 static 域进行首次引用时才执行

初始化有效地实现了尽可能的“惰性”，从对 initable 引用的创建中可以看到，仅使用 .class 语法来获得对类对象的引用不会引发初始化。但与此相反，使用 Class.forName() 来产生 Class 引用会立即就进行初始化
如果一个 static final 值是“编译期常量”（如 Initable.staticFinal），那么这个值不需要对 Initable 类进行初始化就可以被读取。但是，如果只是将一个域设置成为 static 和 final，还不足以确保这种行为。例如，对 Initable.staticFinal2 的访问将强制进行类的初始化，因为它不是一个编译期常量。
如果一个 static 域不是 final 的，那么在对它访问时，总是要求在它被读取之前，要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间），就像在对 Initable2.staticNonFinal 的访问中所看到的那样

与类型的概念一致，instanceof 说的是“你是这个类，还是从这个类派生的类？”。另一方面，如果使用 == 比较实际的 Class 对象，则与继承无关 —— 它要么是确切的类型，要么不是

不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象


假设F(X)代表Java中的一种代码模式，其中X为此模式中可变的部分。如果B是A的派生类，而F(B)也享受F(A)派生类的待遇，那么F模式是协变的，如果F(A)反过来享受F(B)派生类的待遇，那么F模式是逆变的。如果F(A)和F(B)之间不享受任何继承待遇，那么F模式是不变的
1、数组是协变的。
2、extends关键字加持的泛型是协变的。
3、super关键字加持的泛型是逆变的。
4、Java泛型是不变的
5、协变返回类型
里氏代换原则（任何基类可以出现的地方，子类一定可以出现）
T1是一个基类，T2是T1的子类，所有使用T1的地方，都代替为T2之后，程序行为没有发生改变
子类要完全实现父类的抽象方法，但尽量不要覆盖父类的非抽象方法

数组的协变是有缺陷的，数组在java语言中是完全定义的，因此内建了编译期和运行时的检查，协变时赋值错误在编译期无法检测出来，等到运行时才会报错。
但是在使用泛型时，类型信息在编译期被擦除了，运行时也就无从检查。因此，泛型将这种错误检测移入到编译期

producer-extends, consumer-super（PECS）

表示注解信息保存的时长。可选的 RetentionPolicy 参数包括：
SOURCE：注解将被编译器丢弃
CLASS：注解在 class 文件中可用，但是会被 VM 丢弃。
RUNTIME：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。

如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。


“阻塞”，这是服务端编程永恒的经典话题。不管是多进程，多线程，还是协程，大多都是致力于解决IO问题，说白了都是怎么样把阻塞变成非阻塞的手段。
多线程在CPU密集型的作业下的确不能提高性能甚至更浪费时间，但是在IO密集型的作业下则可以提升性能
实际上，从性能的角度来看，在单处理器机器上使用并发是没有意义的，除非其中一个任务可能阻塞
单核CPU的多线程仍然存在线程安全问题

用于支持 Java 代码执行的栈，包含有关此线程已到达当时执行位置所调用方法的信息。它也包含每个正在执行的方法的所有局部变量(包括原语和堆对象的引用)。每个线程的栈通常在 64K 到 1M 之间

“我可以拥有多少线程”这一问题的答案是“几千个”。但是，如果你发现自己分配了数千个线程，那么你可能需要重新考虑你的做法; 恰当的问题是“我需要多少线程？”

在使用并发时，将字段设为 private 特别重要；否则，synchronized 关键字不能阻止其他任务直接访问字段，从而产生资源冲突

根据Java语言规范，您不能将synchronized关键字与构造函数一起使用。这是非法的，会导致编译错误

每个类也有一个锁（作为该类的 Class 对象的一部分），因此 synchronized 静态方法可以在类范围的基础上彼此锁定，不让同时访问静态数据。即类锁可以保证静态变量的线程安全，对象锁做不到

当你的 Java 数据类型足够大（在 Java 中 long 和 double 类型都是 64 位），写入变量的过程分两步进行，就会发生 Word tearing （字分裂）情况。 JVM 被允许将64位数量的读写作为两个单独的32位操作执行^3，这增加了在读写过程中发生上下文切换的可能性，因此其他任务会看到不正确的结果。这被称为 Word tearing （字分裂），因为你可能只看到其中一部分修改后的值。基本上，任务有时可以在第一步之后但在第二步之前读取变量，从而产生垃圾值（对于例如 boolean 或 int 类型的小变量是没有问题的；任何 long 或 double 类型则除外）。
在缺乏任何其他保护的情况下，用 volatile 修饰符定义一个 long 或 double 变量，可阻止字分裂情况

每个线程都可以在处理器缓存中存储变量的本地副本。将字段定义为 volatile 可以防止这些编译器优化，这样读写就可以直接进入内存，而不会被缓存。一旦该字段发生写操作，所有任务的读操作都将看到更改。如果一个 volatile 字段刚好存储在本地缓存，则会立即将其写入主内存，并且该字段的任何读取都始终发生在主内存中。

同步也会让主内存刷新，所以如果一个变量完全由 synchronized 的方法或代码段(或者 java.util.concurrent.atomic 库里类型之一)所保护，则不需要让变量用 volatile。

 一个 原子操作 是不能被线程调度机制中断的操作；一旦操作开始，那么它一定可以在可能发生的“上下文切换”之前（切换到其他线程执行）执行完毕。

 在多核处理器系统，相对于单核处理器而言，可见性问题远比原子性问题多得多。一个任务所做的修改，即使它们是原子性的，也可能对其他任务不可见（例如，修改只是暂时性存储在本地处理器缓存中），因此不同的任务对应用的状态有不同的视图。另一方面，同步机制强制多核处理器系统上的一个任务做出的修改必须在应用程序中是可见的。如果没有同步机制，那么修改时可见性将无法确认。


为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是解耦。
SPI比较常见的例子：

数据库驱动加载接口实现类的加载
JDBC加载不同类型数据库的驱动
日志门面接口实现类加载
SLF4J加载不同提供商的日志实现类
Spring
Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等
Dubbo
Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口

单一元素枚举类通常是实现单例的最佳方式。注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。因为枚举都是默认继承Enum类的，而且是final的，无法被继承
传统的单例模式的另外一个问题是一旦你实现了serializable接口，他们就不再是单例的了,如果你的单例类包含状态的话就变的更复杂了，你需要把他们置为transient状态，但是用枚举单例的话，序列化就不要考虑了

所有的构造方法都必须显式或隐式地调用父类构造方法

延迟初始化常常会导致实现复杂化，而性能没有可衡量的改进

这个条目不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。 相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。 创建额外的对象以增强程序的清晰度，简单性或功能性通常是件好事。

相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。

不要相信 System.gc 和 System.runFinalization 方法。 他们可能会增加 Finalizer 和 Cleaner 机制被执行的几率，但不能保证一定会执行

java中一个方法相继抛出两个异常时，第二个异常会冲掉第一个异常，一般发生在finally语句抛错时

事实上，为了保留你真正想看到的异常，可能会抑制多个异常。 这些抑制的异常没有被抛弃， 而是打印在堆栈跟踪中，并标注为被抑制了。 你也可以使用 getSuppressed 方法以编程方式访问它们，该方法在 Java 7 中已添加到的 Throwable 中

对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 Float.compare(float, float) 方法，对于 double 基本类型的属性，使用 Double.compare(double, double) 方法。虽然你可以使用静态方法 Float.equals 和 Double.equals 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。

HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。

hashCode重写原则
当在一个应用程序执行过程中，如果在 equals 方法比较中没有修改任何信息，在一个对象上重复调用 hashCode 方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。
如果两个对象根据 equals(Object) 方法比较是相等的，那么在两个对象上调用 hashCode 就必须产生的结果是相同的整数。
如果两个对象根据 equals(Object) 方法比较并不相等，则不要求在每个对象上调用 hashCode 都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。

如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择在首次调用 hashCode 时延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全


信息隐藏很重要有很多原因，其中大部分来源于它将组成系统的组件分离开来，允许它们被独立地开发，测试，优化，使用，理解和修改。这加速了系统开发，因为组件可以并行开发。它减轻了维护的负担，因为可以更快速地理解组件，调试或更换组件，而不用担心损害其他组件。
信息隐藏增加了软件重用，因为松耦合的组件通常在除开发它们之外的其他环境中证明是有用的。最后，隐藏信息降低了构建大型系统的风险，因为即使系统不能运行，各个独立的组件也可能是可用的。

如果一个包级私有顶级类或接口只被一个类使用，那么可以考虑这个类作为使用它的唯一类的私有静态嵌套类，这将它的可访问性从包级的所有类减少到使用它的一个类。

有一个关键的规则限制了你减少方法访问性的能力。 如果一个方法重写一个超类方法，那么它在子类中的访问级别就不能低于父类中的访问级别[JLS，8.4.8.3]。 这对于确保子类的实例在父类的实例可用的地方是可用的（Liskov 替换原则，见条目 15）是必要的。 如果违反此规则，编译器将在尝试编译子类时生成错误消息。 这个规则的一个特例是，如果一个类实现了一个接口，那么接口中的所有类方法都必须在该类中声明为 public。

公共类不应该暴露可变属性。 公共类暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有内部类来暴露属性，无论此类是否是可变的。

java会继承父类中default权限以上的成员

父类的private成员不会被子类继承，子类不能访问。但是子类对象的确包含父类的私有成员。 
父类的 包访问成员 继承为子类的包访问成员。就好像他们直接定义在子类中一样。 
父类的 protected 成员继承为子类的protected 成员。就好像他们直接定义在子类中一样。 
父类的 public 成员继承为子类的public 成员，就好像他们直接定义在子类中一样。


一个类不得允许子类化。 这可以通过使类用 final 修饰，但是还有另外一个更灵活的选择。 而不是使不可变类设置为 final，可以使其所有的构造方法私有或包级私有，并添加公共静态工厂，而不是公共构造方法

CountDownLatch 类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦 countdown 锁的计数器已经达到零，不能再重用它。

继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。 即使如此，如果子类与父类不在同一个包中，并且父类不是为继承而设计的，继承可能会导致脆弱性。 为了避免这种脆弱性，使用合成和转发代替继承，特别是如果存在一个合适的接口来实现包装类。 包装类不仅比子类更健壮，而且更强大。这里指的是装饰器模式

好的 API 文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。
派生类可以访问基类中所有的非私有成员。
基类中的private不算接口，所以你在子类中可以为同一函数声明各种acceess类型，因为基类中的private
函数在子类中是看不到的。子类中的同一函数被认为是新的接口，跟父类一点关系都没有。
基类中的protected,public,default在子类中是看的见的，所以在子类中声明同一函数时，被认为是override，这时子类中的acceess权限只能大，不能小，即protected 对protected,public,而public 只能是public。
如果在子类中声明函数的参数不同，被认为是overload，但是不能只是返回参数不同，这个会无法区分。如果两个interface声明的函数只有返回类型不同，会被认为是不兼容。

构造方法绝不能直接或间接调用可重写的方法。 如果违反这个规则，将导致程序失败。 父类构造方法在子类构造方法之前运行，所以在子类构造方法运行之前，子类中的重写方法被调用。 如果重写方法依赖于子类构造方法执行的任何初始化，则此方法将不会按预期运行。

子类是不继承父类的static变量和方法的。因为这是属于类本身的。但是子类是可以访问的。 
子类和父类中同名的static变量和方法都是相互独立的，并不存在任何的重写的关系。

接口不允许包含实例属性或非公共静态成员（私有静态方法除外）

//有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类
也有的把静态内部类称为 嵌套类
在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这个类中定义静态的成员变量与成员方法。
不能够从静态内部类的对象中访问外部类的非静态成员
 * 1.静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。
 * 2.静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。
 * 3.实例化一个非静态的内部类的方法：
 *  a.先生成一个外部类对象实例
 *  OutClassTest oc1 = new OutClassTest();
 *  b.通过外部类的对象实例生成内部类对象
 *  OutClassTest.InnerClass no_static_inner = oc1.new InnerClass();
 *  4.实例化一个静态内部类的方法：
 *  a.不依赖于外部类的实例,直接实例化内部类对象
 *  OutClassTest.InnerStaticClass inner = new OutClassTest.InnerStaticClass();
 *  b.调用内部静态类的方法或静态变量,通过类名直接调用
 *  OutClassTest.InnerStaticClass.static_value
 *  OutClassTest.InnerStaticClass.getMessage()

静态内部类是外围类的一个静态成员，和其他的静态成员一样，也遵守同样的可访问性，即只能访问外部类的静态成员
普通内部类由于必须使用外部类的对象才能创建，所以可以访问外部类的所有成员，且内部无法定义静态成员，因为无法访问，所以即使定义了也没用

支持使用静态成员类而不是非静态类

如果你声明了一个不需要访问宿主实例的成员类，总是把 static 修饰符放在它的声明中，使它成为一个静态成员类，而不是非静态的成员类。 如果你忽略了这个修饰符，每个实例都会有一个隐藏的外部引用给它的宿主实例。 如前所述，存储这个引用需要占用时间和空间。 更严重的是，并且会导致即使宿主类在满足垃圾回收的条件时却仍然驻留在内存中（详见第 7 条）。 由此产生的内存泄漏可能是灾难性的。 由于引用是不可见的，所以通常难以检测到。

虽然 Java 编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。

对于不应该使用原始类型的规则，有一些小例外。 你必须在类字面值（class literals）中使用原始类型。 规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，List.class，String[].class 和 int.class 都是合法的，但 List<String>.class 和 List<?>.class 不是合法的。

使用原始类型可能导致运行时异常，所以不要使用它们。 它们仅用于与泛型引入之前的传统代码的兼容性和互操作性。 作为一个快速回顾，Set<Object> 是一个参数化类型，表示一个可以包含任何类型对象的集合，Set<?> 是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set 是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是


JAVA可移植性的来源的三方面
一、JAVA作为一种虚拟的操作系统（OS）和图形用户界面（GUI）：操作系统可移植性   
即使经过重新编译，大多数的用C和C++编写的Windows程序也不能在Unix或Macintosh系统上运行。这是为什么呢？因为程序员在编写Windows程序时使用了大量的WindowsAPI和中断调用，而Windows程序对系统功能的调用与Unix和Macintosh程序有很大的差别，所以除非将全套WindowsAPI移植到其它操作系统上，否则重编译的程序仍不能运行。JAVA采用了提供一套与平台无关的库函数（包括AWT、UTIL、LANG等等）的方法来解决这个问题。就象JVM提供了一个虚拟的CPU一样，JAVA库函数提供了一个虚拟的GUI环境。JAVA程序仅对JAVA库函数提出调用，而库函数对操作系统功能的调用由各不同的虚拟机来完成。

二、JAVA作为一种编程语言：源代码可移植性  
作为一种编程语言，JAVA提供了一种最简单同时也是人们最熟悉的可移植性–源代码移植。这意味着任意一个JAVA程序，不论它运行在何种CPU、操作系统或JAVA编译器上，都将产生同样的结果。人们使用C、C++也可以产生同样的效果。但是使用C或C++编程人们可以有太多的选择，在许多细节上它都没有严格定义，如：未初始化变量的值、对已释放的内存的存取、浮点运算的尾数值等等。所以除非你一开始就严格按照系统无关的概念来进行设计，否则这种可移植性只能是一种理论上的设想而不能形成实践。总之，尽管C和C++有严密的语法定义，它们的语意（symantics）定义还不是标准的。这种语意上的不统一使得同一段程序在不同的系统环境下会产生不同的结果。有时即使系统情况完全相同而仅仅由于编译器的设置不同也会产生令人意想不到的结果。而JAVA就不同了。它定义了严密的语意结构，而使编译器不承担这方面的工作。另外，JAVA对程序的行为的定义也比C和C++严格

三、JAVA作为一个虚拟机：CPU可移植性   
大多数编译器产生的目标代码只能运行在一种CPU上（如Intel的x86系列），即使那些能支持多种CPU的编译器也不能同时产生适合多种CPU的目标代码。如果你需要在三种CPU（如x86、SPARC和MIPS）上运行同一程序，就必须编译三次。但JAVA编译器就不同了。JAVA编译器产生的目标代码（J-Code）是针对一种并不存在的CPU–JAVA虚拟机（JAVAVirtualMachine），而不是某一实际的CPU

因为字节码，即class文件是按规定标准排列的二进制文件，所以不同操作系统的java编译器都会编译出一致的字节码文件。


关键在于Java编译器的输出并不是可执行的代码，而是字节码 bytecode. 
字节码是一套设计用来在Java运行时系统下执行的高度优化的指令集，该Java运行时系统称为Java虚拟机 JVM. 在其标准形式下，JVM就是一个字节码解释器。 出于对性能的考虑，许多现代语言都被设计为编译型，而不是解释型。
 
将一个Java程序翻译成字节码，有助于它更容易地在一个大范围的环境运行程序。在一个给定的系统中，只要系统运行包存在，任何Java程序都可以在该系统上运行。因此，对字节码进行解释是编写真正可移植性程序的最容易的方法。
 
对Java程序进行解释也有助于它的安全性。因为每个Java程序的运行都在Java虚拟机的控制系啊，Java虚拟机可以包含这个程序并且能组织它在系统之外产生副作用。Java语言的某些限制增强了它的安全性。
 
尽管Java被设计为解释执行的程序，但是技术上Java并不妨碍动态将字节码编译为本机代码。Java虚拟机的一部分JIT(Just In Time)，能根据需要、一部分一部分地将字节码实时编译为可执行代码。它不能讲整个Java程序一次性全部编译为可执行的代码，因为Java要执行各种检查，而这些检查只有在运行时才执行。因此JIT只编译它运行时需要的代码。
 
Java的字节码经过仔细设计，因为很容易便能使用JIT编译技术奖字节码直接转换成高性能的本机代码。Java运行时系统在提供这个特性的同时仍具有平台独立性。


使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证本地代码能工作在任何Java 虚拟机环境。

SUN公司发布的Java 本地接口(JNI)提供了将Java与C/C++、汇编等本地代码集成的方案，该规范使得在 Java 虚拟机内运行的 Java 代码能够与其它编程语言互相操作，包括创建本地方法、更新Java对象、调用Java方法，引用 Java类，捕捉和抛出异常等，也允许 Java代码调用 C/C++或汇编语言编写的程序和库。作为一个标准程序接口，它没有对底层 Java虚拟机的实现施加任何限制

为什么编译原理的教程都最终把要分析的源分析转换成树这种数据结构呢？数据结构中有Stack,Line,List这么多数据结构，各自都有各自的特点。但是Tree这种结构有很强的递归性，也就是说我们可以把Tree的任何结点Node提取出来后，它依旧是一颗完整的Tree。这一点符合我们现在编译原理分析的形式语言，比如我们在函数里面使用函树，循环中使用循环，条件中使用条件等等，那么就可以很直观地表示在Tree这种数据结构上。同样，我们在执行形式语言的程序的时候也是如此的递归性。在编译原理后面的代码生成的部分，就会介绍一种堆栈式的中间代码，我们可以根据分析出来的抽象语法树，很容易，很机械地运用递归遍历抽象语法树就可以生成这种指令代码。而这种代码其实也被广泛运用在其它的解释型语言中。像现在流行的Java,.NET，其底层的字节码bytecode,可以说就是这中基于堆栈的指令代码的。

根据完成任务不同，可以将编译器的组成部分划分为前端（Front End）与后端（Back End）。
前端编译主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间代码生成。
后端编译主要指与目标机有关的部分，包括代码优化和目标代码生成等。
我们可以把将.java文件编译成.class的编译过程称之为前端编译。把将.class文件翻译成机器指令的编译过程称之为后端编译。


CacheBuilder类采用builder设计模式，它的每个方法都返回CacheBuilder本身，直到build方法被调用



编程范式

计算机到底是为纯数学计算服务的大型计算器 还是变通一下 利用好现有的内存资源的状态机？
前者就是函数式编程 后者是面向过程编程 ，两者的根本分歧在于变量和函数的定义

面向对象和面向过程的区别最直观的比喻就如：摇（狗尾巴）和 狗.摇尾巴（）的区别

面向对象的设计有时也会简单地归纳为“将消息发送给对象”

函数式编程的特性
函数是"一等公民"：函数优先，和其他数据类型一样。

只用"表达式"，不用"语句"：通过表达式（expression）计算过程得到一个返回值，而不是通过一个语句（statement）修改某一个状态。

无副作用：不污染变量，同一个输入永远得到同一个数据。

不可变性：前面一提到，不修改变量，返回一个新的值。

由于变量不可变，纯函数编程语言无法实现循环，这是因为For循环使用可变的状态作为计数器，而While循环或DoWhile循环需要可变的状态作为跳出循环的条件。因此在函数式语言里就只能使用递归来解决迭代问题，这使得函数式编程严重依赖递归。

函数式语言当然还少不了以下特性：
高阶函数（Higher-order function）：就是参数为函数或返回值为函数的函数。有了高阶函数，就可以将复用的粒度降低到函数级别，相对于面向对象语言，复用的粒度更低。

偏应用函数（Partially Applied Functions）：一个函数接收一个有多个参数的函数，返回一个需要较少参数的函数。偏函数将一到多个参数在内部固定，然后返回新函数，返回的函数接收剩余的参数完成函数的应用。

柯里化（Currying）：输入一个有多个参数的函数， 返回一个只接收单个参数的函数。

闭包（Closure）：闭包就是有权访问另一个函数作用域中变量的函数.闭包的三个特性：1.闭包是定义在函数中的函数 。2.闭包能访问包含函数的变量。3.即使包含函数执行完了, 被闭包引用的变量也得不到释放。

lambda 不能获得对自身的引用。 在 lambda 中，this 关键字引用封闭实例，这通常是你想要的。 在匿名类中，this 关键字引用匿名类实例。 如果你需要从其内部访问函数对象，则必须使用匿名类

业务逻辑
异常处理
调试
性能

不要错误地认为“创建对象的代价非常昂贵，我们应该要尽可能地避免创建对象”，相反，由于小对象的构造器只做很少量的显式工作，所以，小对象的创建和回收动作是非常廉价的，特别是在现代的JVM实现上更是如此，通过创建附加的对象，提升程序的清晰性，简洁性和功能性，这通常是件好事

反之，通过维护自己的对象池来避免创建对象并不是一种好的做法，除非池中的对象非常重量级。真正正确使用对象池的典型对象示例就是数据库连接池，建立数据库连接的代价是非常昂贵的，重用这些对象非常有意义，而且，数据库的许可可能限制你只能使用一定数量的连接。但是，一般而言，维护自己的对象池必定会把代码弄得很乱，同时增加内存占用，并且还会损害性能。现代的JVM实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能

一般而言，只要是类是自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空


内存泄漏的另一个常见来源是缓存，缓存应该时不时地清除掉没用的项，这项清除工作可以由一个后台线程来完成，或者也可以在给缓存添加新条目的时候顺便进行清理。

创建和销毁一个简单对象的时间大约为5.6ns


重写equals方法步骤
1.使用==操作符检查“参数是否为这个对象的引用”，如果是，返回true

2.使用instanceof操作符检查“参数是否为正确的类型” 或者 用getClass()+非空判断

3.把object参数强转成正确的类型

4.对于该类中的每个关键域检查是否全部匹配

对于float使用Float.compare方法，double使用Double.compare
浮点数的二进制表示用的基本都是IEE754 标准，计算机里浮点数是个近似值


在每个覆盖了equals方法的类中，也必须覆盖hashCode方法，如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap,HashSet和HashTable，但是不用这些集合也就没什么影响

如果一个类实现了Cloneable,Object的clone方法就返回该对象的逐域拷贝，否则就会抛出CloneNotSupportedException异常，这是接口的一种极端非典型的用法，也不值得仿效。

Object.clone属于浅拷贝，当对象中含有可变的引用类型属性时，在复制得到的新对象对该引用类型属性内容进行修改，原始对象响应的属性内容也会发生变化
浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。

深拷贝两种方式：第一种是给需要拷贝的引用类型也实现Cloneable接口并覆写clone方法，然后在被拷贝类的clone方法手动调用该引用类型的clone方法，
第二种则是利用序列化将对象转成二进制流，然后再把二进制流反序列成一个java对象，这时候反序列化生成的对象是一个全新的对象，里面的信息与原对象一样，但是所有内容都是一份新的

    protected Object deepClone() throws Exception{
        //序列化
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        
        oos.writeObject(this);
        
        //反序列化
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        
        return ois.readObject();
    }

clone方法有很多缺点（必须实现Cloneable接口、抛出异常、浅拷贝，final无法调用clone等），不建议使用，除非拷贝数组


返回类型支持协变，参数也支持，覆盖方法的返回类型可以是被覆盖方法的返回类型的子类


事实上java平台类库中的所有值类都实现了Comparable接口
将这个对象与指定的对象进行比较，当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数，如果无法比较，则抛出ClassCastException异常

BigDecimal的compareTo方法与equals不一致，如果你创建了一个HashSet实例，并且添加new BigDecimal("1.0")和new BigDecimal("1.00"),这个集合就将包含两个元素，因为这两个实例通过equals比较并不相等，然而如果使用TreeSet来存储，则集合将只包含一个元素，因为这两个实例compeareTo方法是相等的

Comparable接口包含泛型，compareTo方法的参数是泛型类型，而不是Object

不建议使用两数相减的结果作为compareTo方法的返回值

信息隐藏可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用、理解和修改，这样可以加快系统开发的速度，因为这些模块可以并行开发

如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超类中的访问级别，这样可以确保任何可使用超类的实例的地方都可以使用子类的实例，如果你违反了这条规则，那么会编译错误（里氏替换原则）

实例域和静态域决不能是公有的，除非是不可变的常量
让公有类暴露不可变的域其危害比较小
然而，如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误

不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。java平台类库中包含许多不可变的类，其中有String、基本类型的包装类、BigInteger和BigDecimal。不可变类比可变类更加易于设计、实现和使用，不容易出错且更加安全。


为了使类成为不可变
1.不要提供任何会修改对象状态的方法
2.保证类不会被扩展 final
3.使所有的域都是final的
4.使所有的域都成为私有的
5.确保对于任何可变组件的互斥访问

不可变对象可以只有一种状态，即被创建时的状态，它的所有方法调用不会修改自身的状态，只会返回全新的对象
不可变对象本质上是线程安全的，当多个线程并发访问时，它们不会遭到破坏

不可变类真正唯一的缺点是：对于每个不同的值都需要一个单独的对象
如果你执行一个多步骤的操作（循环）并且每个步骤都会产生一个新的对象，除了最后的结果之外其他的对象最终都会被丢弃，此时性能问题就会显露出来
解决这个问题最好的办法就是提供一个公有的可变配套类，在java平台中，主要例子是String，可变配套类是StringBuilder（和基本上已经废弃的StringBuffer）
相对于BIgInteger 可变配套类是BitSet。

让类不可子类化的两种方式：1.final修饰 2.让类的所有构造器私有

当BigInteger和BigDecimal刚被编写出来的时候，对于 不可变的类必须是final的 还没得到广泛地理解，所以他们的所有方法都有可能会被覆盖

除非有令人信服的理由要使域变成是非final的，否则要使每个域都是final的


Java BitSet
bit的index和整型数值相等，如：存储127，那么BitSet中的第127位bit就被置为1。查找127是否在BitSet中，只需使用MASK进行与操作即可
但是可以想象到，BitSet中至少需要有多少位bit，决定于存储在BitSet中的最大整型值。所以如果存储的整型值的范围是0到一千万，而总共只有0，100，一千万三个值，那么就很浪费空间了，就是本来几十个字节的东西，用了1M的空间。所以适用BitSet的场景是要数值范围越小越好，也就是说数值越集中越好。比如都集中在一千万到一千万零2之间，那么用3位bit就可以搞定了，当然要转换以下，一千万就用0代替存储在BitSet中，查询的时候也用0代替查，以此类推。还有一个限制就是，存储的值不能重复，即BitSet不能存储重复的值

Java中目前的实现是使用long数组。使用的肯定是1<<value循环移位了，但是首先要计算出value存储在数组中哪个long中，然后再对该long值移位。查询也是，先查出这个value在哪个long中，然后再使用MASK进行与操作查询


在包内部使用继承是非常安全的，因为子类和超类的实现都是处在同一个程序员控制下，然而，对普通的具体类进行跨越包边界的继承，则是非常危险的

与方法调用不同的是，继承打破了封装性，子类依赖于其超类中特定功能的实现细节，子类与父类耦合在一起

普通的类是为组合而设计，而不是为继承而设计

在java平台类库中，有许多违反继承的地方，例如 Stack并不是Vector,Properties不应该扩展Hashtable

好的API文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的

对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化

常量接口模式是对接口的不良使用

使用Comparator匿名类对象时，可以考虑将该函数对象存储到一个私有的静态final域里

每个泛型都定义一个原生态类型，即不带任何实际参数的泛型名称，如 与List<E>对应的原生态类型是List，为了兼容java没有泛型之前的代码
如果使用原生态类型，就失掉了泛型在安全性和表述性方面的优势

可以将List<String>传递给List的参数（编译时不会报错，运行时可能会报错），但是不能将它传给类型List<Object>的参数
泛型有子类型化的规则，List<String>是原生态类型List的一个子类型，但不是List<Object>的子类型

在不确定泛型类型或者不关心泛型类型的情况下也不应该使用原生态类型，而是使用泛型无限制通配符
如计算两个set的元素总数 int getTotal(Set<?> s1, Set<?> s2){}

永远不要在整个类上使用SuppressWarnings，这么做可能会掩盖了重要的警告

数组与泛型相比，有两个比较重要的不同点：
1.数组是协变的，泛型是不可变的
如果Sub是Super的子类型，那么数组类型Sub[]是Super[]的子类型
相反地，List<Sub>并不是List<Super>的子类型，即Object[] o1 = new String[1]可以编译通过，List<Object> o2 = new ArrayList<String>()编译不通过
且String[]可以传递给入参为Object[]的方法，返回值为Object[]的方法也可以实际返回String[]，泛型是都不可以的
赋值，传参，返回值都是支持协变的
这其实是数组的缺陷而不是泛型的缺陷

2.数组是具体化的，因此数组会在运行时才知道并检查它们的元素类型约束，相比之下，泛型则是通过擦除来实现的，因此泛型只在编译时强化它们的类型信息，并在运行时丢弃它们的元素信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用

由于上述这些根本的区别，因此数组与泛型不能很好地混合使用，new List<String>[]、new E[]都是非法的

不能创建不可具体化的类型的数组，如 E[] arr = new E[]，每当编写用数组支持的泛型时，都会出现这个问题，可以直接创建Object数组然后强制转换成E[]


泛型类的声明 
class Test<E>{
	private E e;	
}

泛型方法的声明 
public static <E> Set<E> union(Set<E> s){}
或者
int getTotal(Set<?> s1, Set<?> s2){
		return 1;
}

泛型方法的一个显著特性是，无需明确指定类型参数的值，不像调用泛型构造器的时候是必须指定的，编译器通过检查方法参数的类型来计算类型参数的值，对于上述的程序而言，编译器发现union的两个参数都是Set<String>类型，因此知道类型参数E必须为String。这个过程称作类型推导

在调用泛型构造器的时候，要明确传递类型参数的值可能有点麻烦，类型参数出现在了变量声明的左右两边，显得有些冗余
Map<String,List<String>> map = new HashMap<String, List<String>>()
不过jdk1.7之后就可以省略了，泛型构造器的类型推导和泛型方法一致了

因为List<String>不是List<Object>的子类型，所以无法将String放入List<Object>中，为了提升灵活性，可以使用有限通配符
List<? Extends Object>

枚举的构造方法不能在类外部使用

java的枚举本质上是int值
背后的基本想法非常简单，就是通过公有的静态final域为每个枚举常量导出实例的类
因为没有可以访问的构造器，枚举类型是真正的final，因为客户端既不能创建枚举类型的实例，也不能对它进行扩展，枚举类型是实例受控的，它们是单例的泛型化，本质上是单元素的枚举

枚举常量值并没有被编译到客户端代码中

枚举类型允许添加任意的方法和域，并实现任意接口，它们提供了所有Object方法的高级实现，实现了Comparable和Serializable接口

在枚举类型中声明一个抽象的方法，并在特定常量的类主体中，用具体的方法覆盖每个常量的抽象方法，这种方法被称作 特定于常量的方法实现

最好避免使用Enum的ordinal方法

标记接口 是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口，例如Serializable接口
标记接口有两点胜过标记注解
1.标记接口定义的类型是由被标记类的实例实现的，这个类型允许你在编译时捕捉在使用标记注解的情况下要到运行时才能捕捉到的错误
就Serializable接口而言，如果它的参数没有实现该接口，ObjectOutputStream.write(Object)方法将会失败。令人不解的是，ObjectOutputStream API的创建者在声明write方法时并没有利用Serializable接口，该方法的参数应该为Serializable而非Object

2.标记接口可以被更加精确地进行锁定

java是一门安全的语言，这意味着，它对于缓存区溢出，数组越界，非法指针以及其他的内存破坏错误都自动免疫
在设计类的时候，可以确切地知道，无论系统的其他部分发生什么事情，这些类的约束都可以保持为真，对于那些“把所有内存当作一个巨大的数组来看待”的语言来说，这是不可能的

final修饰的变量并不是真正的不可变，只是引用不可变，但内部属性仍可修改，将内部所有属性也置为final的才可以彻底实现不可变

参数的保护性拷贝和返回值的保护性拷贝都是为了保护类的不可变性，但是如果类内部所有属性都是不可变的，那保护性拷贝也就没有存在的必要了

重载方法的选择是静态的（编译器就确定），被覆盖的方法选择是动态的（运行时才确定）

安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法，如果方法使用可变参数，保守策略是根本不要重载它

应该使用接口而不是用类作为参数的类型，更一般地讲，应该优先使用接口而不是类来引用对象。如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。除非类提供了某种特殊的功能，而这种功能并不在接口提供的方法中

反射机制的缺点
丧失了编译时类型检查的好处，所有类信息的异常都只会在运行时抛出（类方法，域不存在等）
反射的代码笨拙和冗长
性能损失
反射方法调用比普通方法慢了许多，具体慢了多少，很难说

总而言之，不要费力去编写快速的程序，应该努力编写好的程序，速度自然会随之而来

类型参数 T表示任意的类型，E表示集合的元素类型，K，V表示映射的键和值类型

因为异常机制的设计初衷是用于不正常的情形，所以很少有JVM实现试图对它们进行优化，使得与显示的测试一样快速
实际上，在现代的JVM实现上，基于异常的模式比标准模式要慢得多

异常应该只用于异常的情况下，它们永远不应该用于正常的控制流

Throwable是一个class
java提供了三种可抛出的Throwable，包括受检的异常（checked exception）,运行时异常（run-time exception）和错误（error）
对可恢复的情况使用受检异常，对编程错误使用运行时异常，往往属于不可恢复的情形，继续执行下去有害无益

永远不要声明一个方法“throws Exceptiong” 或者 “throws Throwable”


要阻止一个线程妨碍另一个线程，建议做法是让第一个线程轮询一个boolean域，这个域一开始为false，可以通过第二个线程设置为true，以表示第一个线程将终止自己。但是切记，这个域一定要是volatile的，因为VM会将域值查询代码做优化

不确定的时候不要在方法内部同步，而应该让调用方在外部处理同步
例如StringBuffer所有的方法都加了同步，所以该类基本已经废弃了

大多数ExecutorService实现，包括ThreadPoolExecutor都使用BlockingQueue

java.util.concurrent中分为三类：Executor Framework,并发集合以及同步器
最常用的同步器是CountDownLatch和Semaphore

wait与notify比较难用，一般可以用CountDownLatch来替换
没有理由在新代码中使用wait与notify

始终应该使用wait循环模式来调用wait方法，永远不要在循环之外调用wait方法

类按线程安全可分为Immutable、ThreadSafe和NotThreadSafe

对于可变对象如果发生变化后会对程序产生较大的影响，最好声明称final的，把可变性减到最小

延迟初始化 除非绝对必要，否则就不要这么做

线程优先级是java平台上最不可移植的特征

虽然使一个类可被序列化的直接开销非常低，但是长期来看代价是很大的
1.一旦一个可序列化的类被发布，就大大降低了 改变这个类的实现的灵活性，你无法再随意的修改删除该类

2.增加了出现bug和安全漏洞的可能性
序列化机制是一种语言之外的对象创建机制，无论你是接受了默认的行为，还是覆盖了默认的行为，反序列化机制都是一个隐藏的构造器

3.序列化耗时很多 序列化逻辑并不了解对象图的拓扑关系，所以它必须要经过一个昂贵的图遍历

4.可能会引起栈溢出
默认的序列化过程要对对象图执行一次递归遍历，即使对于中等规模的对象图也可能引起栈溢出，比如过长的链表

因为Throwable类实现了序列化接口，所以RMI的异常可以从服务器端传到客户端

默认的序列化形式，对transient的域都会有一个默认值，如果不能接受就必须提供一个readObject方法，它首先调用defaultReadObject,然后把这些transient域恢复为可接受的值

不管你选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显式的序列版本UID，这样可以避免序列化版本UID成为潜在的不兼容根源，如果没有提供，就需要在运行时通过一个高开销的计算过程产生一个序列化版本UID

readObject方法实际上相当于另一个公有的构造器
不严格的说，readObject是一个 用字节流作为唯一参数 的构造器，在正常使用下，对一个正常构造的实例进行序列化可以产生字节流，但是当面对一个人工仿造的字节流时，readObject产生的对象会违反它所属的类约束条件。
为了修正这个问题，你可以为类提供一个readObject方法，该方法首先调用defaultReadObject，然后检查被反序列化之后的对象的有效性，如果有效性检查失败，readObject方法就会抛出一个InvalidObjectException异常，使反序列化不能成功地完成

任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，因此反序列化会破坏单例对象
如果你将一个可序列化的实例受控的类编写成枚举，就可以绝对保证除了所声明的常量外，不会有别的实例，JVM对此提供了保障

当我们在使用一门技术时，如果不再依赖书本的他人就能得到这个问题的答案。那才算是升华到了“不惑”的境界


