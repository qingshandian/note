java 与 C++

C++ 名称来自于递增运算符，暗示着“比 C 更进一步”。在早期的 Java 演讲中，Bill Joy（Java 作者之一）说“Java = C++ --”（C++ 减减），意味着 Java 在 C++ 的基础上减少了许多不必要的东西，因此语言更简单。随着进一步地学习，我们会发现 Java 的确有许多地方相对 C++ 来说更简便，但是在其他方面，难度并不会比 C++ 小多少。

在某些语言中，必须显式地授予方法后期绑定属性的灵活性。例如，C++ 使用virtual关键字。在这些语言中，默认情况下方法不是动态绑定的。在 Java 中，动态绑定是默认行为，不需要额外的关键字来实现多态性


是否所有的类都应该默认从一个基类继承呢？这个答案在 Java 中是肯定的（实际上，除 C++ 以外的几乎所有OOP语言中也是这样） C++ 所使用的多继承的方案则是不保证所有的对象都属于同一个基类
java8的多接口实现间接实现了多继承（接口允许写default实现方法）

在 C++ 程序设计中，当使用完一个对象后，必须明确将其删除，这就让问题变复杂了,在 C++ 中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏

与 Java 不同，C++不会在编译时进行检查以确定函数或方法是不是真的抛出异常，或者异常说明是不是完整（也就是说，异常说明有没有精确描述所有可能被抛出的异常）。这样的检查只发生在运行期间。如果抛出的异常与异常说明不符，C++会调用标准类库的 unexpected() 函数。

在 C/C++ 中，对象的操纵是通过指针来完成的


C/C++ 允许开发者向编译器建议寄存器的分配
如果可以用 Java 在栈内存上创建对象，就像在C++ 中那样的话


在 C 和 C++ 中使用数组是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存（常见编程错误），则结果是不可预测的
在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据

在 C、C++ 和 Java 中，作用域是由大括号 {} 的位置决定的
在 C/C++ 中将一个较大作用域的变量"隐藏"起来的做法，在 Java 中是不被允许的。 因为 Java 的设计者认为这样做会导致程序混乱


这些默认值仅在 Java 初始化类的时候才会被赋予。这种方式确保了基本类型的属性始终能被初始化（在C++ 中不会），从而减少了 bug 的来源

在 Java 逻辑运算中，我们不能像 C/C++ 那样使用非布尔值， 而仅能使用 AND、OR、NOT

Java 也添加了一种“不分正负”的右移位运算符（>>>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。这一运算符是 C/C++ 没有的

于是在 C++ 里引入了“运算符重载”机制，以便 C++ 程序员为几乎所有运算符增加特殊的含义。但遗憾得是，与 C++ 的一些限制结合以后，它变得复杂。这要求程序员在设计自己的类时必须对此有周全的考虑。虽然在 Java 中实现运算符重载机制并非难事（如 C# 所展示的，它具有简单的运算符重载），但因该特性过于复杂，因此 Java 并未实现它


在 C++ 中你甚至可能犯这样极端的错误.代码示例：
while(x = y) {
// ...
}

在 C/C++ 中，经常需要用到 sizeof() 方法来获取数据项被分配的字节大小

在 Java 中使用数值作为布尔值是非法的，即便这种操作在 C/C++ 中是被允许的

当垃圾回收器准备回收对象的内存时，首先会调用其 finalize() 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用 finalize() ，就能在垃圾回收时做一些重要的清理工作。finalize() 是一个潜在的编程陷阱，因为一些程序员（尤其是 C++ 程序员）会一开始把它误认为是 C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必要明确区分一下：在 C++ 中，对象总是被销毁的（在一个 bug-free 的程序中），而在 Java 中，对象并非总是被垃圾回收，或者换句话说：

对象可能不被垃圾回收。
垃圾回收不等同于析构。

与 Java 不同，C++不会在编译时进行检查以确定函数或方法是不是真的抛出异常，或者异常说明是不是完整（也就是说，异常说明有没有精确描述所有可能被抛出的异常）。这样的检查只发生在运行期间。如果抛出的异常与异常说明不符，C++会调用标准类库的 unexpected() 函数


C++，通常会认为性能比安全更重要。用Java编程比C++（一般认为大概快两倍）快的原因是Java的安全性网络：这种特征类似于垃圾回收以及键入检查。通过将单元测试集成到构建过程中，你扩大了这个安全网，有了更快的开发效率。当发现设计或实现的缺陷时，可以更容易、更大胆重构你的代码。

用于String的+与+=是Java中仅有的两个重载过的操作符，Java不允许程序员重载任何其他的操作符 

C++允许编程人员任意重载操作符。这通常是很复杂的过程（参见Prentice Hall于2000年编写的《Thinking in C++（第2版）》第10章），因此Java设计者认为这是很糟糕的功能，不应该纳入到Java中。起始重载操作符并没有糟糕到只能自己去重载的地步，但具有讽刺意味的是，与C++相比，在Java中使用操作符重载要容易得多

假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。对C++/C这样的语言来说这是很困难的，因为你无法返回一个数组，只能是返回一个指向数组的指针。这会带来一些问题，因为对数组生存期的控制变得很混乱，这会导致内存泄露

如果你具备 C++ 或者其他底层的知识背景，你可能会认为自增是一个原子操作，因为 C++ 的自增操作通常被单个微处理器指令所实现

比起面向对象编程中其他的概念来，接口和内部类更深奥复杂，比如 C++ 就没有这些。将两者结合起来，同样能够解决 C++ 中的用多重继承所能解决的问题。然而，多重继承在 C++ 中被证明是相当难以使用的，相比较而言，Java 的接口和内部类就容易理解多了。

Java与C/C++的编译器对比实际上代表了最经典的即时编译器与静态编译器的对比，很大程度上也决定了Java与C/C++的性能对比结果，因为无论是C/C++还是Java代码，最终编译之后被机器执行的都是本地机器码。哪种语言的性能更高，除了它们自身的API库实现得好坏之外，其余的比较就成了拼编译器和输出代码质量

首先，即时编译器运行占用的是用户程序运行的时间，而编译的时间成本在静态优化编译器中并不是主要的关注点
其次，Java语言是动态的类型安全语言，这意味着虚拟机必需频繁地进行动态检查，如实例方法检查空指针、数组检查上下界范围、类型转换时检查继承关系等

第三，Java使用虚方法的频率远远大于C/C++

第四，Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行

第五，Java语言中对象的内存分配都是在堆上进行的，只有方法中的局部变量才能在栈上分配，而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力

但上述Java语言的这些劣势都是为了换取开发效率上的优势而付出的代价，动态安全、动态扩展、垃圾回收这些特性都为Java语言的开发效率做出了很大的贡献





