POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。
使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。

JavaBean是一个可重复使用的软件组件。实际上JavaBean是一种Java类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。
JavaBean 是一种JAVA语言写成的可重用组件。它的方法命名，构造及行为必须符合特定的约定：
这个类必须有一个公共的缺省构造函数。
这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。
这个类应是可序列化的。 
因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO

spring
Spring为开发者提供的是一个一站式的轻量级应用开发框架，作为平台，Spring抽象了我们在许多应用开发中遇到的共性问题，同时，作为一个轻量级的应用开发框架，Spring和传统的J2EE开发相比，有其自身的特点。通过这些自身的特点，Spring充分体现了它的设计理念，在Java EE的应用开发中，支持POJO和使用JavaBean的开发方式，使应用面向接口开发，充分支持OO的设计方法

在Java EE应用开发中，传统的EJB开发需要依赖按照J2EE规范实现的J2EE应用服务器。我们的应用在设计，特别是实现时，往往需要遵循一系列的接口标准，才能够在应用服务器的环境中得到测试和部署。这种开发方式，使应用在可测试性和部署上都会受到一些影响。Spring的设计理念采用了相对EJB而言的轻量级开发思想，即使用POJO的开发方式，只需要使用简单的Java对象或者JavaBean就能进行JavaEE开发，这样开发的入门、测试、应用部署都得到了简化

另一方面，在我们的应用开发中，往往会涉及复杂的对象耦合关系，如果在Java代码中处理这些耦合关系，对代码的维护性和应用扩展性会带来许多不便。而如果使用Spring作为应用开发平台，通过使用Spring的IOC容器，可以对这些耦合关系实现一个文本化、外部化的工作，也就是说，通过一个或几个XML文件，我们就可以方便地对应用对象的耦合关系进行浏览、修改和维护，这样，可以在很大程度上简化应用开发。同时，通过IOC容器实现的依赖反转，把依赖关系的管理从Java对象中解放出来，交给了IOC容器来完成，从而完成了对象之间的关系解耦

作为应用平台，Spring与Unix、Windows这样传统意义的操作系统在计算机系统中的作用类似，即作为用户和机器之间的平台，同时也为用户使用底层的机器资源提供了应用开发环境。不同点在于，操作系统关心的是对存储、计算、通信、外围设备等物理资源的管理，并在管理这些资源的基础上，为用户提供一个统一的服务接口，而对于像Spring这样的JavaEE企业应用而言，其关心的是一些企业应用资源的使用，比如数据持久化、数据集成、事务处理、消息中间件、分布式计算等技术抽象。具体来说，在J2EE开发中，EJB提供了一种模式，而Spring提供了另一种POJO的开发模式，虽然开发模式不同，也就是使用具体资源的模式不同，但出发点却都是一样的

在对Spring的内部设计进行分析时，也可以依据对传统操作系统的认知方法，在设计上把Spring划分为核心、组件和应用3个基本的层次
Spring体系的核心，类似操作系统的Kernel，即IOC容器和AOP模块。对spring来说，一方面，它通过IOC容器来管理POJO对象，以及它们相互之间的耦合关系，使企业的信息数据资源可以用简单的Java语言来抽象和描述，另一方面，可以通过AOP，以动态和非侵入式的方式来增强服务的功能，所以，我们可以把IOC容器和AOP模块看做是Spring的Kernel，是平台实现的核心部分，作为核心，它们代表了最为基础的底层抽象，同时也是Spring其他模块实现的基础
Spring的设计理念-面向接口开发而不依赖于具体的产品实现

Spring IOC：包含了最为基本的IOC容器BeanFactory的接口和实现，如XmlBeanFactory，SimpleJndiBeanFactory等，除此之外，Spring还设计了IOC容器的高级形态ApplicationContext应用上下文供用户使用

Spring AOP：围绕着AOP的增强功能，Spring集成了AspectJ作为AOP的一个特定实现，同时还在JVM动态代理/CGLIB的基础上，实现了一个AOP框架，作为Spring集成其他模块的工具，比如声明式事务

Spring MVC：这个模块以DispatcherServlet为核心，实现了MVC模式，包括怎样与Web容器环境的集成，Web请求的拦截、分发、处理和ModelAndView数据的返回，以及如何集成各种UI视图展现和数据表现

Spring JDBC/Spring ORM：Spring JDBC包提供了JdbcTemplate作为模板类，封装了基本的数据库操作方法。另外除了通过Spring JDBC对数据库进行操作外，Spring还提供了许多对ORM工具的封装，这些封装包括了常用的ORM工具，如Hibernate、iBatis等，这一层的封装是让应用更方便地使用这些ORM工具，而不是替代这些ORM工具

Spring事务处理：Spring事务处理是一个通过Spring AOP实现自身功能增强的典型模块

Spring远端调用：Spring为应用带来的一个好处就是能够将应用解耦，这种远端调用是通过Spring的封装从Spring应用到Spring应用之间的端到端调用，这个过程中，通过Spring的封装，为应用屏蔽了各种通信的调用来实现，比如可以使用HTTP调用器，RMI、Hessian

Spring应用：Spring子项目，比如Spring Security OAuth

Spring的价值
Spring是一个非侵入性框架，其目标是使应用程序代码对框架的依赖最小化
Spring提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以与运行环境隔离开来
Spring推动了应用的设计风格向面向对象及面向接口编程转变，提高了代码的重用性和可测试性
Spring改进了体系结构的选择，虽然作为应用平台，Spring可以帮助我们选择不同的技术实现


Spring 应用上下文中所有的 bean 都会给定一个ID。如果我们没有明确地设置ID，Spring 会根据类名为其指定一个ID。具体来讲，就是将类名的第一个字母变为小写。

如果我们没有为 @ComponentScan 设置任何属性。这意味着，按照默认规则，它会以配置类所在的包作为基础包（base package）来扫描组件

基于注解的bean需要被扫描到才可以使用，即需要在xml中添加<context:component-scan base-package="context" />
类似地，对于使用AOP注解的切面也需要添加 <aop:aspectj-autoproxy />
使用注解事务需要添加<tx:annotation-driven />
xml bean和JavaConfig生成的并不需要

尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置 Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加 @Component 和 @Autowired 注解的，因此就不能使用自动化装配的方案了。
在这种情况下，你必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：JavaConfig 和 XML。

默认情况下，JavaConfig bean 的 ID 与带有 @Bean 注解的方法名是一样的。如果你想为其设置成一个不同的名字的话，那么可以重命名该方法，也可以通过 name 属性指定一个不同的名字。

如果方法上添加了 @Bean 注解， Spring 将会拦截所有对它的调用，并确保直接返回该方法所创建的 bean，而不是每次都对其进行实际的调用

<bean class="soundsystem.SgtPeppers" />
因为没有明确给定 ID，所以这个 bean 将会根据全限定类名来进行命 名。在本例中，bean 的 ID 将会是 “soundsystem.SgtPeppers#0”。其中，“#0” 是一个计数的形式，用来区分相同类型的其他 bean。如果你声明了另外一个 SgtPeppers，并且没有明确进行标识，那么它自动得到的 ID 将会是 “soundsystem.SgtPeppers#1”

id和name都是spring 容器中中bean 的唯一标识符。
id: 一个bean的唯一标识，命名格式必须符合XML ID属性的命名规范
name: 可以用特殊字符，并且一个bean可以用多个名称：name=“bean1,bean2,bean3” ,用逗号或者分号或者空格隔开。如果没有id，则name的第一个名称默认是id

p-命名空间 和 c-命名空间 无法装配集合
可以使用util-命名空间中转下

关于混合配置，第一件需要了解的事情就是在自动装配时，它并不在意要装配的 bean 来自哪里。自动装配的时候会考虑到 Spring 容器中所有的 bean，不管它是在 JavaConfig 或 XML 中声明的还是通过组件扫描获取到的。

@Qualifier定义或者使用bean的限定符（别名）

Spring 定义了多种作用域，可以基于这些作用域创建 bean，包括：
单例（Singleton）：在整个应用中，只创建 bean 的一个实例。
原型（Prototype）：每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新的 bean 实例。
会话（Session）：在 Web 应用中，为每个会话创建一个 bean 实例。
请求（Rquest）：在 Web 应用中，为每个请求创建一个 bean 实例。


一些编程语言例如Ruby和Groovy，有开放类的理念，可以不用修改对象或类的定义就能够为对象或类增加新的方法，不过Java并不是动态语言，一旦类编译完成了，我们就很难再为该类添加新的功能

与 AspectJ 相比，Spring AOP 是一个功能比较弱的 AOP 解决方案，SpringAOP无法增强构造器


IOC容器
依赖反转：如果合作对象的引用或依赖关系的管理由具体对象来完成，会导致代码的高度耦合和可测试性的降低，这对复杂的面向对象系统的设计是非常不利的。在面向对象系统中，对象封装了数据和对数据的处理，对象的依赖关系常常体现在对数据和方法的依赖上，这些依赖关系可以通过把对象的依赖注入交给框架或IOC容器来完成，这种从具体对象手中交出控制的做法是非常有价值的，它可以在解耦代码的同时提高代码的可测试性
依赖控制反转的实现有很多种方式，在Spring中，IOC容器是实现这个模式的载体，它可以在对象生成或初始化时直接将数据注入到对象中，也可以通过将对象引用注入到对象数据域中的方式来注入对方法调用的依赖
关于如何反转对依赖的控制，把控制权从具体业务对象手中转交到平台或者框架中，是降低面向对象系统设计复杂性和提高面向对象系统可测试性的一个有效的解决方案。它促进了IOC设计模式的发展，是IOC容器要解决的核心问题
IOC原理的应用在不同的语言中有很多实现，比如SmallTalk、C++、Java等，在同一语言的实现中也会有多个具体的产品，Spring是Java语言实现中最著名的一个

控制反转本质上就是把原来需要自己创建的对象交给容器去帮忙创建
通过使用IOC容器，对象依赖关系的管理被反转了，转到IOC容器中来了，对象之间的相互依赖关系由IOC容器进行管理，并由IOC容器完成对象的注入，这样就在很大程度上简化了应用的开发，把应用从复杂的对象依赖关系管理中解放出来。
简单来说，因为很多对象依赖关系的建立和维护并不需要和系统运行状态有很强的关联性，所以可以把在面向对象编程中需要执行的诸如新建对象，为对象引用赋值等操作交由容器统一完成。这样一来，这些散落在不同代码中的功能相同的部分就集中称为容器的一部分，也就是成为面向对象系统的基础设施的一部分

如果对面向对象系统中的对象进行简单分类，会发现除了一部分是数据对象外，其他很大一部分对象是用来处理数据的，这些对象并不常发生变化，是系统中基础的部分。在很多情况下，这些对象在系统中以单件的形式起作用就可以满足应用的需求，而且他们也不常设计数据和状态共享的问题。如果涉及数据共享方面的问题，需要在这些单件的基础上再做进一步的处理

同时，这些对象之间的相互依赖关系也是比较稳定的，一般不会随着应用的运行状态的改变而改变。这些特性使这些对象非常适合由IOC容器来管理

在EJB模式中，应用开发人员需要编写EJB组件，而这种组件需要满足EJB容器的规范，才能够运行在EJB容器中，从而获取事务管理，生命周期管理这些组件开发的基本服务。从获取的服务上看，Spring提供的服务和EJB容器提供的服务并没有太大的区别，只是在具体怎样获取服务的方式上，两者的设计有很大的不同，对于EJB，一个简单的EJB组件需要编写远程/本地接口、Home接口以及Bean的实现类，而且EJB运行是不能脱离EJB容器的，查找其他EJB组件也需要通过诸如JNDI这样的方式，从而造成了对EJB容器和技术规范的依赖。也就是说Spring把EJB组件还原成了POJO对象或者JavaBean对象，降低了应用开发对传统J2EE技术规范的依赖

J2EE优点是什么？使用J2EE的主要原因是多层结构，传统的两层C/S结构难于维护，稳定性极差，界面代码和数据库代码混淆在一起，牵一动百，多层结构使得界面和数据库完全分离，并且诞生了中间件这样的技术


EJB(Enterprise Java Bean)是JavaEE中面向服务的体系架构的解决方案，可以将功能封装在服务器端，以服务的形式对外发布，客户端在无需知道方法细节的情况下来远程调用方法，大大降低了模块间的耦合性，提高了系统的安全性和可维护性。
"面向服务"，是软件开发过程中，异构环境下模块调用的一个比较重要的思想。同样，面向服务也只是一种设计思想，不是一种编程技术。由"面向服务"的思想，业界提出了"面向服务的体系结构(Service Oriented Architecture, SOA)"的概念。

作为IOC容器，需要为它的具体实现指定基本的功能规范，这个功能规范的设计表现为接口类BeanFactory

对IOC容器来说，BeanDefinition就是对依赖反转模式中管理的对象依赖关系的数据抽象，也就容器实现依赖反转功能的核心数据结构，依赖反转功能都是围绕对这个BeanDefinition的处理来完成的，这些BeanDefinition就像是容器里的水

BeanFactory是IOC容器的最基本接口，ApplicationContext的设计中，一方面，它继承了BeanFactory接口体系中的ListableBeanFactory、AutowireCapableBeanFactory等BeanFactory接口，另一方面，通过继承MessageSource、ResourceLoader这些接口，被赋予了更高级的IOC容器特性

在Spring中，所有的Bean都是由BeanFactory来进行管理的，但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能产生或者修饰对象生成的工厂Bean

BeanFactory接口设计了getBean方法，这个方法是使用IOC容器API的主要方法，通过这个方法，可以取得IOC容器中管理的Bean，Bean的取得是通过指定名字来索引的
有了BeanFactory的定义，用户可以执行以下操作：
通过接口方法containsBean让用户能够判断容器是否含有指定名字的bean
通过接口方法isSingleton来查询指定名字的Bean是否是Singleton类型的Bean，类似地isPrototype
通过接口方法getType来查询指定名字的Bean的Class类型

XmlBeanFactory继承自DefaultListableBeanFactory，后者实际包含了基本IOC容器所具有的重要功能，也是在很多地方都会用到的容器系列中的一个基本产品
在Spring中，实际上是把DefaultListableBeanFactory作为一个默认的功能完整的IOC容器来使用的，XmlBeanFactory只是增加了XML相关的功能

在XmlBeanFactory构造方法中需要得到Resource对象，对XmlBeanDefinitionReader对象的初始化，以及使用这个对象来完成对loadBeanDefinitions的调用，就是这个调用启动从Resource中载入BeanDefinitions的过程，LoadBeanDefinitions同时也是IOC容器初始化的重要组成部分
ClassPathResource res = new ClassPathResource("beans.xml")
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(res);
IOC容器建立的基本步骤

ApplicationContext提供了以下BeanFactory不具备的新特性
支持不同的信息源 扩展了MessageSource接口
访问资源 继承了DefaultResourceLoader
支持应用事件 继承了接口ApplicationEventPublisher
附加服务

IOC容器的初始化是由refresh()方法来启动的，这个方法标志着IOC容器的正式启动，具体来说，包括Resource定位、载入和注册三个过程

第一个过程是Resource定位过程，这个Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，比如，在文件系统中可以使用FileSystemResource来进行抽象，类路径可以使用ClassPathResource,这个定位过程类似于容器寻找数据的过程，就像用水桶装水先要找到水一样
 
第二个过程是BeanDefinition的载入，这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构。而这个容器内部的数据结构就是BeanDefinition

第三个过程是向IOC容器注册这些BeanDefinition的过程，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的，这个注册过程把载入过程中解析得到的BeanDefinition向IOC容器进行注册。通过分析，我们可以看到，在IOC容器内部将BeanDefinition注入到一个HashMap中去，IOC容器就是通过这个HashMap来持有这些BeanDefinition数据的

这里谈的是IOC容器初始化过程，在这个过程中，一般不包含Bean依赖注入的实现。在Spring Ioc的设计中，Bean定义的载入和依赖注入是两个独立的过程。依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候。但如果我们对某个Bean设置了lazyint属性，那么这个Bean的依赖注入在IOC容器初始化时就预先完成了


DTD 与 XSD
DTD是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确

XSD是XML Schema语言，本身也是XML文件，也是用来规范和约束特定的XML文件的，其自身符合基本的XML语法结构，可以用通用的XML解析器解析它
它包含两个部分，一部分是名称空间的URI，另一部分是该名称空间所标识的XML Schema文件位置或URL地址

Spring读取xml配置文件用来检测验证模式的办法就是判断是否包含DOCTYPE，如果包含就是DTD，否则就是XSD

xml文件生成Resource -> Resource获取输入流 -> 根据输入流读取xml文件内容，判断xml文件是DTD还是XSD -> 生成xml文件的Document对象 -> 获取Document对象根节点 -> 解析根节点的profile属性，如果有的话 -> 获取根节点下的子节点 -> 判断各子节点是否为default节点（import,alias,bean,beans四个节点其中之一）或者自定义标签（除了前面的四种之外的都是自定义标签），然后循环依次处理 -> 假设是bean，开始bean标签的解析 -> 解析bean标签的class、name、id、alias之类的属性 -> 创建GenericBeanDefinition -> 对解析后的BeanDefinitionHolder进行注册

bean标签的解析：

BeanDefinition
BeanDefinition是配置文件<bean>元素标签在容器中的内部表现形式，BeanDefinition和<bean>中的属性是一一对应的
BeanDefinition是一个接口，在Spring中存在三种实现：RootBeanDefinition、ChildBeanDefinition、GenericBeanDefinition，三种均继承了AbstractBeanDefinition

Spring通过BeanDefinition将配置文件中的<bean>配置信息转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中，Spring容器的BeanDefinitionRegistry就像是Spring配置信息的内存数据库，主要是以map的形式保存，后续操作直接从BeanDefinitionRegistry中读取配置信息

解析完成的beanDefinition都会被注册到BeanDefinitionRegistry类型的实例registry中，注册又被分为两个部分，通过beanName的注册以及通过别名的注册
对于beanDefinition的注册，就是将beanDefinition直接放入map中就好了，使用beanName作为key，除此之外，spring还做了点别的事情

alias标签的解析：
和之前bean标签中alias解析大同小异，都是将别名与beanName组成一对注册至registry中

import标签的解析：
获取resource属性所表示的路径
解析路径中的系统属性，格式如“${user.dir}”
判定location是绝对路径还是相对路径
将路径包装成resource，再走一次上述的解析流程
通知监听器，解析完成

嵌入式beans标签的解析：
与import标签类似


自定义标签使用
当系统配置较为复杂或者需要更多丰富控制的时候，基于标准bean来配置会显得很笨拙，一般的做法会用原生态的方式去解析定义好的XML，然后转化为配置对象，但实现起来比较繁琐，Spring提供了可扩展Schema的支持，实现步骤如下：
创建一个需要扩展的组件
定义一个XSD文件描述组件内容
创建一个文件，实现BeanDefinitionParser接口，用来解析XSD文件中的定义和组件定义
创建一个Handler文件，扩展自NamespaceHandlerSupport，目的是将组件注册到Spring容器
编写Spring.handlers和Spring.schemas
Spring加载自定义的大致流程是遇到自定义标签然后就去Spring.handlers和Spring.schemas中去找对应的Handler的XSD，默认位置是META—INF/下，进而找到对应的Handler以及解析器Parser，自定义与Spring中默认的标准配置不同在于Spring将自定义标签解析的工作委托给了用户去实现。Spring自己的自定义标签也是这样，例如tx、aop、context标签


Bean的加载

在创建单例bean的时候会存在依赖注入的情况，在创建依赖的时候为了避免循环依赖，Spring创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光，也就是将ObjectFactory加入到缓存中，一旦下个bean创建的时候需要依赖上个Bean则直接使用ObjectFactory
在getBean方法内部一开始就会直接尝试从缓存或者singletonFactories中的ObjectFactory中获取
注意，只有在单例情况才会尝试解决循环依赖，原型模式下，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次
返回创建A，造成循环依赖
bean加载主要流程(doGetBean方法)
1.转换对应的beanName transformedBeanName(name)去除FactoryBean的修饰符或者取指定alias所表示的最终beanName
2.尝试从缓存中加载单例
单例在Spring的同一个容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了
3.bean的实例化
如果从缓存中得到了bean的原始状态，则需要对bean进行实例化，这里有必要强调一下，缓存中记录的只是最原始的bean状态

Bean的加载
在创建单例bean的时候会存在依赖注入的情况，在创建依赖的时候为了避免循环依赖，Spring创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光，也就是将ObjectFactory加入到缓存中，一旦下个bean创建的时候需要依赖上个Bean则直接使用ObjectFactory
在getBean方法内部一开始就会直接尝试从缓存或者singletonFactories中的ObjectFactory中获取
注意，只有在单例情况才会尝试解决循环依赖，原型模式下，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次
返回创建A，造成循环依赖

bean加载主要流程(doGetBean方法)
1.转换对应的beanName transformedBeanName(name)去除FactoryBean的修饰符或者取指定alias所表示的最终beanName
2.尝试从缓存中加载单例
单例在Spring的同一个容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了
3.bean的实例化
如果从缓存中得到了bean的原始状态，则需要对bean进行实例化，这里有必要强调一下，缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean，getObjectForBeanInstance会完成这个工作
4.原型模式的依赖检查
只有在单例情况下才会尝试解决循环依赖，原型模式下的循环依赖会直接报错
5.检测parentBeanFactory
检测如果当前加载XML配置文件中不包含beanName所对应的配置，就只能到parentBeanFactory去尝试，然后再去递归的调用getBean方法
6.将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition
因为从xml配置文件中读取到的Bean信息是存储在GernericBeanDefinition中的，但是所有的Bean后续处理都是针对于RootBeanDefinition的，所以这里需要进行一个转换，转换的同时如果父类bean不为空的话，则会一并合并父类的属性
7.寻找依赖
因为bean的初始化过程中很可能会用到某些属性，而某些属性很可能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖
8.针对不同的scope进行bean的创建
9.类型转换
将返回的bean转换为requiredType所指定的类型

FactoryBean的使用

一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean，在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案，Spring为此提供了一个FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。
FactoryBean接口对于Spring框架来说占有重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利
当配置文件中<bean>的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法，如果希望获取FactoryBean的实例，则需要在使用getBean(beanName)方法时在beanName前显式的加上"&"前缀
缓存中获取单例Bean

singletonObjects:用于保存BeanName和创建bean实例之间的关系
singletonFactories:用于保存BeanName和创建bean的工厂之间的关系
earlySingletonObjects:也是保存BeanName和创建bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用
registeredSingletons:用来保存当前所有已注册的bean

从bean的实例中获取对象

在getBean方法中，getObjectForBeanInstance是个高频使用的方法，无论是从缓存中获得bean还是根据不同的scope策略加载bean，我们得到bean实例后要做的第一件事就是调用这个方法来检测一下正确性，其实就是用于检测当前bean是否是FactoryBean类型的bean，如果是那么需要调用该bean对应的FactoryBean实例中的getObject()作为返回值
单例bean创建外层步骤getSingleton(String beanName, ObjectFactory singletonFactory)
1.检查缓存是否已经加载过
2.若没有加载，则记录beanName的正在加载状态
3.加载单例前记录加载状态
4.通过调用参数传入的ObjectFactory的个体Object方法实例化bean(实际创建bean的方法)
5.加载单例后的处理方法调用，当bean加载结束后需要移除缓存中对该bean的正在加载状态的记录
6.将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态
7.返回处理结果

准备创建bean

处理override属性，在Spring配置中存在lookup-method和replace-method两个配置功能，而这两个配置的加载其实就是将配置统一存放在BeanDefinition中的methodOverrides属性里，这两个功能的实现原理其实是在bean实例化的时候如果检测到存在methodOverrides属性，会动态地为当前bean生成代理并使用对应的拦截器为bean做增强处理
实例化前的后处理器应用

在bean实例化之前，会给子类一个修改BeanDefition的机会，也就是说当程序经过这个方法后，bean可能已经不是我们认为的bean了，而是或许成为了一个经过处理的代理bean，可能是通过cglib生成的，若此处处理后得到的bean不为空就直接返回该bean，不进行后续的bean创建过程了，所以在这里会直接应用后处理器的postProcessAfterInitialization方法
spring如何解决循环依赖

1.构造器循环依赖
通过构造器注入构成的循环依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常，Spring容器将每一个正在创建的bean标识符放在一个当前创建的bean池，bean标识符在创建过程中将一直保持在这个池中，因此如果在创建bean过程中发现自己已经在当前创建bean池中，将抛出BeanCurrentlyInCreationException异常表示循环依赖，创建完成时会从池中清除掉
例如bean a通过构造器注入bean b，bean b通过构造器注入bean a，Spring容器首先创建bean a，将a标识符放到当前创建bean池，继续准备其需要的构造器参数bean b，开始创建bean b，将b标识符放到当前创建bean池，继续准备其需要的构造器参数bean a，这时发现a已经在当前创建bean池中，便会报错
2.setter循环依赖
对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例的bean循环依赖，通过提前暴露一个单例工厂方法，从而使其他bean能引用到该bean
Spring容器创建单例bean a，首先根据无参构造器创建bean，并暴露一个ObjectFactory用于返回一个提前暴露一个创建中的bean，并将a标识符放到当前创建的bean池，然后进行setter注入bean b，同理在b中进行setter注入a时，由于提前暴露了ObjectFactory工厂，从而使用它返回提前暴露的一个创建中的bean a，最后完成了setter注入
对于prototype作用域bean，Spring无法完成依赖注入，因为Spring容器不进行缓存该作用域的bean，因此无法提前暴露一个创建中的bean
继续创建bean
当经历过resolveBeforeInstantiation方法后，程序有两个选择，如果创建了代理或者说重写了postProcessBeforeInstantiation方法并在方法中改变了bean，则直接返回就可以了，否则需要进行常规bean的创建
doCreateBean
1.如果是单例则需要首先清除缓存
2.实例化bean，将BeanDefinition转换为BeanWrapper，大致过程如下：如果存在工厂方法则使用工厂方法进行初始化，如果一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化，如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行bean的实例化
3.对单例bean在bean初始化完成前将创建实例的ObjectFactory加入singletonFactories缓存
4.对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始化依赖bean
5.调用初始化方法，比如init-method
6.循环依赖检测
7.根据scope注册bean

属性注入populateBean

1.InstantiationAwareBeanPostProcessor处理器的postProcessAfterInstantiation函数的应用，此函数可以控制程序是否继续进行属性填充
2.根据注入类型，提取依赖的bean，并统一存入PropertyValues中（递归初始化依赖bean）
3.应用InstantiationAwareBeanPostProcessor处理器的postProcessPropertyValues方法，对属性获取完毕填充前对属性的再次处理
4.将所有的PropertyValues中的属性填充至BeanWrapper中
spring如果发现@Autowired变量是一个List和一个Map集合，他会将容器中匹配集合元素类型的所有Bean都注入进来，Map中Key是Bean的名字，value是所有某类型的Bean

初始化bean initializeBean

处理bean配置中的init-method属性，该方法的执行位置位于Spring bean实例化并且进行了属性的填充之后，虽然说此方法的主要目的是进行客户设定的初始化方法的调用，但是除此之外还有些其他必要的工作
1.激活Aware方法
Spring中提供了一些Aware相关接口，比如BeanFactoryAware, ApplicationContextAware, ResourceloaderAware, ServletContextAware等，实现这些Aware接口的bean在初始化后，Spring容器将会注入BeanFactory的实例
2.处理器的应用
BeanPostProcessor是Spring中开放式架构中一个必不可少的亮点，给用户充足的权限去更改或者扩展Spring，而除了BeanPostProcessor外还有很多其他的PostProcessor，大部分都是以此为基础，其使用位置就是这里，在调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization方法，使用户可以根据自己的业务需求进行相应的处理
注意：1.BeanFactory和ApplicationContext两个容器对待bean的后置处理器稍微有些不同，Application容器会自动检测Spring配置文件中那些bean所对应Java类实现了beanPostProcessor接口，并自动把它们注册为后置处理器，在创建bean过程中调用它们
2.BeanFactory容器注册bean后置处理器时必须通过代码显式的注册
3.postProcessBeforeInitialization和postProcessAfterInitialization方法不能返回null
4.多个后置处理器在默认情况下Spring容器会根据后置处理器的定义顺序来依次调用，也可以通过实现getOrder方法自定义优先级
3.激活自定义的init方法
用户定制的初始化方法除了我们熟知的Init-method外，还有使bean实现InitialzingBean接口，并在afterPropertiesSet中实现自己的初始化业务逻辑，int-method于afterPropertiesSet都是在初始化bean时执行，顺序是after先，init-method后
注册DisposableBean
Spring中不但提供了对于初始化方法的扩展入口，同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，处理配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanPostProcessor来统一处理bean的销毁方法
容器的扩展功能ApplicationContext
ApplicationContext和BeanFactory两者都是用于加载Bean的，但是相比之下，ApplicationContext提供了更多的扩展功能

使用BeanFactory加载XML
BeanFactory bf = new XmlBeanFactory(new ClassPathResource("bean.xml"));
使用ApplicationContext加载XML
ApplicationContext bf = new ClassPathXmlApplicationContext("bean.xml");

ClassPathXmlApplicationContext初始化步骤

1.初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证
2.初始化BeanFactory，并进行XML文件读取
这一步将会复用BeanFactory中的配置文件读取解析及其他功能，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能，也就是可以进行Bean的提取等基础操作了
3.对BeanFactory进行各种功能填充
@Qualifier与@Autowired正是在这一步中增加的支持
4.子类覆盖方法做额外的处理（扩展功能）
5.激活各种beanFactory处理器
6.注册拦截bean处理器BeanPostProcessor，只是注册，真正的调用在getBean
7.为上下文初始化Message源，对不同语言的消息体进行国际化处理
8.初始化应用消息广播器
9.留给子类来初始化其他bean
10.在所有注册的bean中查找listener bean，注册到消息广播器中
11.初始化剩下的单实例
12.完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知

BeanFactoryPostProcessor实现该接口可以在Spring的bean创建之前，修改bean的定义属性，也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其他bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，很明显，它要先于BeanPostProcessor方法执行，BeanFactoryPostProcessor的典型应用：PropertyPlaceholderConfig负责解析bean属性配置中spEL表达式
上面第6点是一个很重要的步骤，也是很多功能BeanFactory不支持的重要原因，Spring中大部分功能都是通过后处理器的方式进行扩展的，这是Spring框架的一个特性，但是在BeanFactory中其实并没有实现后处理器的自动注册，所以在调用的时候如果没有进行手动注册其实是不能使用的，但是ApplicationContext中添加了自动注册功能
上述第11步 初始化非延迟加载
ApplicationContext实现的默认行为就是在启动时将所有的单例bean提前进行实例化，提前实例化意味着作为初始化过程的一部分，ApplicationContext实例会创建并配置所有的单例bean。通常情况下这是一件好事，因为这样在配置中的任何错误就会即刻被发现，而这个实例化的过程就是在finishBeanFactoryInitialzation中完成的

AOP

Spring对于AOP的实现，基本上都是靠AnnotationAwareAspectJAutoProxyCreator去完成，它可以根据@Point注解定义的切点来自动代理相匹配的bean
proxy-target-class:Spring AOP部分使用JDK动态代理或者CGLIB来为目标对象创建代理（建议尽量使用JDK的动态代理），如果被代理的目标对象实现了至少一个接口，则会使用JDK动态代理，若该目标对象没有实现任何接口，则创建一个CGLIB代理，如果你希望强制使用CGLIB代理，例如希望代理目标对象的所有方法，而不只是实现自接口的方法，可将该属性设置为true，CGLIB代理有两个问题，一是无法增强final方法，二是需要额外引用相关jar包
JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理
CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类，CGLIB是高效的代码生成包，底层是依靠ASM操作字节码实现的，性能比JDK强
expose-proxy:对于目标对象内部的自我方法调用将无法实施切面的增强，这时需要将该属性设置为true
AnnotationAwareAspectJAutoProxyCreator实现了BeanPostProcessor接口，当Spring加载其他bean时会在实例化后调用其postProcessAfterInitialization方法
该方法内部会判断是否有需要增强的方法，如果有的话需要创建代理，创建代理主要包含两个步骤：
1.获取增强方法或增强器 2.根据获取的增强进行代理
对于步骤1：先获取所有的beanName，遍历所有的bean找出Aspect注解的类，解析标记AspectJ注解中的增强方法，获取方法上的注解，提取得到的注解中的表达式得到切点信息，然后根据切点信息生成增强，所有的增强都由Advisor的实现类InstantiationModelAwarePointcutAdvisorImpl统一封装，Spring会根据不同的注解生成不同的增强器，例如AtBefore会对应AspectJMethodBeforeAdvice中完成了增强方法的逻辑，虽然此时已经完成了所有增强器的解析，但是对于当前bean并不一定都适用，还要挑选出适合的增强器
对于步骤2：代理类的创建及处理，Spring委托给了ProxyFactory去处理

使用CGLIB代理的判断条件 isOptizime || isProxyTargetClass || hasNoUserSuppliedProxyInterfaces
如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP
如果目标对象实现了接口，可以强制使用CGLIB实现
如果没有对象没有实现接口，必须采用CGLIB

Spring AOP JDK代理实现也是用来Proxy和InvocationHandler这两个东西，在整个创建过程中，对于InvocationHandler的创建是最为核心的，在自定义的InvocationHandler中需要重写3个函数
1.构造函数，将代理的对象传入
2.invoke方法，此方法中实现了AOP增强的所有逻辑
3.getProxy方法 

CGLIB

CGLIB是一个强大的高性能的代码生成包，它广泛被许多AOP框架使用，例如Spring AOP和dynaop，为它们提供方法的拦截，最流行的OR Mapping工具Hibernate也使用CGLIB来代理单端关联，EasyMock和jMock是通过使用moke对象来测试Java代码的包，它们都是使用CGLIB来为那些没有接口的类创建Moke对象
CGLIB底层使用小而快的字节码处理框架ASM，来转换字节码并生成新的类，除了CGLIB，脚本语言例如Groovy和BeanShell也是使用ASM来生成Java的字节码，当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉
CGLIB是在运行时动态生成一个代理类的子类class并载入使用，类似于匿名内部类

创建AOP静态代理

AOP的静态代理主要是在虚拟机启动时通过改变目标对象字节码的方式来完成对目标对象的增强，它与动态代理相比具有更高的效率，因为在动态代理调用的过程中，还需要一个动态创建代理类并代理目标对象的步骤，而静态代理则是在启动时便完成了字节码增强，当系统再次调用目标类时与调用正常的类并无差别，所以在效率上会相对高些
Instrumentation使用
java在1.5引入java.lang.instrument，你可以由此实现一个java agent，通过此agent来修改类的字节码即改变一个类，它类似一种更低级、更松耦合的AOP，可以从底层来改变一个类的行为
java.lang.instrument把java的instrument功能从本地代码中解放出来，使用可以用java代码的方式解决问题，使用instrument开发者可以构建一个独立于应用程序的代理程序，用来监测和协助运行在JVM上的程序，甚至能够替换和修改某些类的定义，这样的特性实际上提供了一种虚拟机级别支持的AOP实现方式
实现方式：1.编写一个带有premain函数的Java类 2.将这个Java类打包成一个Jar文件，并在其中的MAINIFEST.MF属性指定步骤1中的Java类 2.在jvm启动参数中加上 java -javaagent:jar 文件的位置
Spring中的静态AOP直接使用了AspectJ提供的方法，而AspectJ又是在Instrument基础上进行的封装

Spring JDBC

Spring容器的事务机制的实质是对传统JDBC的封装，也即是Spring事务管理无论是对单数据库实例还是分布式数据库实例，要实现事务管理，那么必须保证在一个事务过程获得Connection对象是同一个，那么即使在同一个函数中调用其他多个的函数，通过Spring框架的AOP动态代理机制，使得Spring容器底层能够按照传统JDBC的方式进行事务管理。从而保证对这个函数做事务控制
Spring框架具有支持多数据源的特性，在获得数据库Connection对象往往是通过DataSource中获得，DataSource这个接口往是由不同的厂商驱动实现，因此Spring框架是对DataSource进一步的封装保证每次获得的Connection为相同，这就保证了一个业务方法里面进行多次Dao操作，调用的都是一个connection对象，同时保证多个dao都是在一个事务里面
从Spring源码可以知道，数据库连接从TransactionSynchronizationManager中获得，如果已经存在则获得，否则重新从DataSource创建一个连接，并把这个连接封装为ConnectionHolder，然后注册绑定到TransactionSynchronizationManager中，并返回Connection对象。
TransactionSynchronizationManager内部用ThreadLocal对象存储资源，ThreadLocal存储的为DataSource生成的actualKey为key值和ConnectionHolder作为value值封装成的Map。结合DataSourceUtils的doGetConnection函数和TransactionSynchronizationManager的bindResource函数可知：在某个线程第一次调用时候，封装Map资源为：key值为DataSource生成actualKey【Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);】value值为DataSource获得的Connection对象封装后的ConnectionHolder。等这个线程下一次再次访问中就能保证使用的是第一次创建的ConnectionHolder中的Connection对象。当事务结束后，调用【DataSourceUtils.releaseConnection(con, getDataSource());】将ConnectionHolder从TransactionSynchronizationManager中解除。当谁都不用，这个连接被close
PreparedStatement 实例包含已编译的SQL语句，这就是使语句准备好，包含于PreparedStatement对象中的SQL语句可具有一个或多个IN参数，IN参数的值在SQL语句创建时未被指定，相反的，该语句为每个IN参数保留了一个问号作为占位符，每个问号的值必须在该语句执行之前，通过适当的setXXX方法来提供
由于PreparedStatement对象已预编译过，所以其执行速度要快于Statement对象

spring事务

默认情况下Spring中的事务处理只对RuntimeException方法进行回滚，所以，如果将此处将RuntimeException替换成普通的Exception不会产生回滚效果
SpringMVC
Spring的MVC是基于servlet功能实现的。通过实现Servlet接口的DispatchServlet来封装其核心功能实现，通过将请求分派给处理程序，同时带有可配置的处理程序映射、视图解析、本地语言、主题解析以及上传文件支持
SpringMVC或者其他比较成熟的MVC框架而言，解决的问题都是以下几点：
1.将Web页面的请求传给服务器
2.根据不同的请求处理不同的逻辑单元
3.返回处理结果数据并跳转至响应的页面

SpringMVC快速体验

1.配置web.xml
一个Web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的，web.xml文件用来初始化配置信息：比如welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。但是，SpringMVC的实现原理是通过servlet拦截所有url来达到控制的目的，所以web.xml的配置是必须的
Spring MVC之所以必须要配置web.xml，其实最关键的是要配置两个地方
contextConfigLocation: Spring的核心就是配置文件，而这个参数就是使web与Spring的配置文件相结合的一个关键配置
DispatcherServlet:包含了SpringMVC的请求逻辑，Spring使用此类拦截web请求并进行相应的逻辑处理
2.创建Spring配置文件applicationContext.xml
InternalResourceViewResolver是一个辅助Bean，会在ModelAndView返回的视图名前加上prefix指定的前缀，在最后加上suffix指定的后缀
当使用编程方式的时候我们可以直接将Spring配置信息作为参数传入Spring容器中，如：
ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml")
但是在web下，我们需要更多的是与web环境相互结合，通常的办法是将路径以context-param的方式注册并使用ContextLoaderListener进行监听读取，ContextLoaderListener的作用就是启动web容器时，自动装配ApplicationContext的配置信息，因为它实现了ServletContextListener这个接口，使用ServletContextListener接口，开发者能够在为客户端请求提供服务之前向ServletContext中添加任意的对象，这个对象在servletContext启动的时候被初始化，然后再ServletContext整个运行期间都是可见的，每一个web应用都有一个ServletContext与之关联。ServletContext对象在应用启动时被创建，在应用关闭时被销毁，ServletContext在全局范围内有效，类似于应用中的一个全局变量，在ServletContextListener中的核心逻辑便是初始化WebApplicationContext实例并存放至ServletContext中

Last-Modified缓存机制
1.在客户端第一次输入url时，服务端会返回内容的状态码200，表示请求成功，同时会添加一个Last-Modified的响应头，表示此文件在服务器上的最后更新时间
2.客户端第二次请求此url时，客户端会向服务器发送请求头If-Modified-Since，询问服务器该时间之后当前请求内容是否有被修改过，如果服务器端的内容没有变化，则自动返回HTTP 304(只要响应头，内容为空，这样就节省了带宽)
