redis是Remote Dictionary Server远程字典服务的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容，同大多数脚本语言中的字典一样，Redis字典中的键值除了可以是字符串，还可以是其他数据类型。Redis支持的键值数据类型如下：

字符串类型 散列类型 列表类型 集合类型 有序集合类型

Redis虽然是作为数据库开发的，但由于其提供了丰富的功能，越来越多的人将其用作缓存、队列系统等，Redis可以为每个键值设置生存时间，生存时间到期后键会自动被删除，这一功能配合出色的性能让Redis可以作为缓存系统来使用，而且由于Redis支持持久化和丰富的数据类型，使其成为了缓存系统memcached的有力竞争者

在性能上Redis是单线程模型，而memcached支持多线程，所以在多核服务器上后者的性能理论上相对更高一些，然而，Redis的性能已经足够优异，在绝大部分场合下其性能都不会成为瓶颈，所以在使用时更应该关心的是二者在功能上的区别，随着Redis3.0的推出，标志着memcached已经成了Redis的子集，因此，在新项目中使用Redis替代memcached将会是非常好的选择

作为缓存系统，Redis还可以限定数据占用的最大内存空间，在数据达到空间限制后可以按照一定的规则自动淘汰不需要的键

除此之外，Redis的列表类型键可以用来实现队列，并且支持阻塞式读取，可以很容易实现一个高性能的优先级队列

Redis是开源的，使用C语言开发，代码量只有3万多行，这降低了用户通过修改Redis源码来使之更适合自己项目需要的门槛

Redis约定次版本号（即第一个小数点后的数字）为偶数的版本是稳定版（如2.8,3.0），奇数的是非稳定版

考虑到Redis有可能正在将内存中的数据同步到硬盘中，强制终止Redis进程可能会导致数据丢失，正确停止Redis的方式应该是向Redis发送shutdown命令，方法为：redis-cli SHUTDOWN,当Redis收到shutdown命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出，Redis可以妥善处理SIGTERM信号，所以使用kill Redis进程的pid也可以正常结束redis

一个redis默认支持16个数据库，每个数据库对外都是以一个从0开始的递增数字命名，客户端与redis建立连接后会自动选择0号数据库，然而这些以数字命名的数据库又与我们理解的数据库有所区别，首先redis不支持自定义数据库的名字，多个数据库之间并不是完全隔离的，这些数据库更像是一种命名空间，不适宜存储不同应用程序的数据

KEYS * 获取所有的键

SET bar 1 设置键bar的值为1

EXISTS key 判断一个键是否存在

DEL key [key ...] 删除一个或多个键

TYPE key 用来获得键值的数据类型，返回值可能是string、hash、list、set、zset

当存储的字符串是整数形式时，redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值，当要操作的键不存在时会默认键值为0，所以第一次递增后的结果是1，当键值不是整数时redis会提示错误，包括INCR在内的所有redis命令都是原子操作

redis对于键的命名并没有强制的要求，但比较好的实践是用“对象类型:对象id:对象属性”来命名一个键，如使用user:1:friends来存储id为1的用户的好友列表，对于多个单词则推荐使用"."分隔

INCRBY key increment 增加指定的整数

DECR key decrement减少指定的整数

INCRBYFLOAT key increment增加指定浮点数

除了散列类型，redis的其他数据类型同样不支持数据类型嵌套，比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表

HSET key field value

HGET key field

HSET命令不区分插入和更新操作，当执行的是插入操作时返回1，更新操作返回0

在redis中每个键都属于一个明确的数据类型，使用一种数据类型的命令操作另一种数据类型的键会提示错误

HGETALL key 返回的是所有字段和字段值组成的列表

HEXISTS key field 用来判断一个字段是否存在

HSETNX key field value 与HSET命令类似，区别在于如果字段已经存在，HSETNX命令将不执行任何操作

HDEL key field 可以删除一个或多个字段

HKEYS key 获取所有的字段名 HVALS key 获取所有的字段值

list内部是使用双向链表实现的，所以向列表两端添加元素的时间复杂度为O(1)，获取越接近两端的元素速度就越快

LPUSH key value 向列表左边增加元素 返回值表示增加后列表的长度

RPUSH key value 向列表右边增加元素

LPOP key  RPOP key 将列表左右边的元素从列表中移除，然后返回被移除的元素

LRANGE key start stop 获得列表中的某一片段

LREM key count value删除列表中前count个值为value的元素

LINDEX key index 返回指定索引的元素

RPOPLPUSH source destination 将元素从一个列表转到另一个列表

集合类型set

set在redis内部是使用值为空的散列表实现的，操作的时间复杂度都是O(1)

SADD key member 增加一个或多个元素，如果键不存在则会自动创建，如果要加入的元素已经存在就会忽略这个元素，返回值是成功加入的数量

SREM key member 从集合中删除一个或多个元素，并返回删除成功的个数

SMEMBERS 返回集合中的所有元素

SISMEMBER key member 判断一个是否在集合中

SDIFF key [key...] 对多个集合执行差集运算

SINTER key [key...] 对多个集合执行交集运算

SUNION 并集运算

SPOP key 随机从集合中弹出一个元素

有序集合zset

为集合中的每个元素都关联了一个分数，不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高的前N个元素，虽然集合中每个元素都是不同的，但是它们的分数却可以相同

ZADD key score member 向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数

ZSCORE key member 获取元素的分数

ZRANGE key start stop 获得排名在某个范围内的元素列表，如果两个元素分数相同，按字典顺序来进行排列

Redis中的事务是一组命令的集合，事务同命令一样都是Redis的最小执行单位

首先使用命令MULTI命令开启事务通知，接下来执行多个redis命令，最后使用EXEC命令告诉redis将之前的命令按照发送顺序依次执行，EXEC命令返回值就是这些命令的返回值组成的列表，返回值顺序和命令的顺序相同

Redis保证一个事务中的所有命令要么都执行，要么都不执行，如果在发送EXEC命令前客户端断线了，则redis会清空事务队列，事务中的所有命令都不会执行，而一旦客户端发送了EXEC命令，所有的命令就都会执行，即使此后客户端断线也没关系，因为redis中已经记录了所有要执行的命令

除此之外，redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入

在事务中如果存在一条命令有语法错误，执行EXEC命令后redis就会直接返回错误，连语法正确的命令也不会执行

而如果在事务中执行一条命令时报错，即出现运行时错误，事务里其他的命令依然会继续执行

redis的事务没有关系数据库事务提供的回滚功能，为此开发者必须在事务执行出错后自己将数据库复原回事务执行前的状态

WATCH

在一个事务中只有当所有命令都依次执行完后才能得到每个结果的返回值，可是有些情况下需要先获得一条命令的返回值，然后再根据这个值执行下一条命令，这时需要watch命令，watch可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行，监控一直持续到EXEC命令

EXPIRE key seconds设置一个key的过期时间，到时间后redis会自动删除它

TTL 返回键的剩余存活时间，-1表示永久存活

PERSIST 取消键的过期时间设置

由于EXPIRE是一条单独的执行命令，为防止其他命令执行成功，该命令执行失败从而导致的严重问题，最好加上事务控制

修改配置文件的maxmemory参数，限制redis最大可用内存大小，当超出这个限制时redis会依据maxmemory-policy参数指定的策略来删除不需要的键直到redis占用的内存小于指定内存，一般采用LRU(Least Recently Used)算法，即最近最少使用

SORT list/set/zset  DESC/ESC LIMIT 1 2

在对zset排序时会忽略元素的分数，只针对元素自身的值进行排序

默认情况下SORT会直接返回排序结果，如果希望保存排序结果，可以使用STORE参数

SORT是redis中最强大最复杂的命令之一，如果使用不好很容易成为性能瓶颈

在开发中使用SORT命令时需要注意以下几点：

1.尽可能减少待排序键中元素的数量 2.使用LIMIT参数只获取需要的数据 3.如果要排序的数据量较大，尽可能使用STORE参数将结果缓存

使用redis实现任务队列

BRPOP命令和RPOP命令相似，唯一的区别是当列表中没有元素时BRPOP命令会一直阻塞住连接，直到有新元素加入，BRPOP命令接收两个参数，第一个是键名，第二个是超时时间，单位是秒，当超过了此时间仍然没有获得新元素的话就会返回nil

BRPOP命令可以同时接收多个键，如果多个键的list都有元素则按照从左到右的顺序取第一个键中的一个元素，借此特性可以实现区分优先级的任务队列

发布订阅模式

发布者发布消息的命令是PUBLISH，用法是PUBLISH channel message，PUBLISH命令的返回值表示接收到这条消息的订阅者数量，订阅频道的命令是SUBSCRIBE，可以同时订阅多个频道，用法是SUBSCRIBE channel [...]，执行SUBSCRIBE命令后客户端会进入订阅状态，处于此状态下客户端不能使用除SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这4个属于发布订阅模式命令之外的命令，否则会报错

Redis的底层通信协议对管道提供了支持，通过管道可以一次发送多条命令并在执行完后一次性将结果返回，当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发出，管道通过减少客户端与redis的通信次数来实现降低往返时延累计值的目的

redis在2.6版推出了脚本功能，允许开发者使用lua语言编写脚本传到redis中执行，使用脚本的好处如下：

1.减少网络开销：不使用脚本的话，多条redis命令需要往redis发送多次请求，使用脚本只需要一次请求即可，减少了网络往返时延

2.原子操作：redis会将整个脚本作为一个整体执行，中间不会被其他命令插入，在编写脚本的过程中无需担心会出现竞态条件，也就无需使用事务，事务可以完成的所有功能都可以用脚本实现

3.复用：客户端发送的脚本会永久存储在redis中，这就意味着其他客户端可以复用这一脚本而不需要使用代码完成同样的逻辑

很多人都希望在redis中加入各种各样的命令，这些命令中有的确实很实用，但却可以使用多个redis已有的命令实现，在redis中包含所有开发者需要的命令显然是不可能的，所有redis在2.6版中提供了lua脚本功能来让开发者自己扩展redis

EVAL命令

EVAL 脚本内容 key参数的数量 key[...] [arg...]，可以通过key和arg这两类参数向脚本传递数据

例如：EVAL "return redis.call('SET', KEYS[1], ARGV[1])" 1 foo bar

考虑到在脚本比较长的情况下，如果每次调用脚本都需要将整个脚本传给redis会占用较多的带宽，为了解决这个问题，redis提供了EVALSHA命令允许开发者通过脚本内容的SHA1摘要来执行脚本，该命令的用法和EVAL一样，只不过是将脚本内容替换成脚本内容的SHA1摘要

redis在执行EVAL命令时会计算脚本的SHA1摘要并记录在脚本缓存中，执行EVALSHA命令是Redis会根据提供的摘要从缓存中查找对应的脚本内容，如果找到了则执行脚本，否则会返回错误

redis的脚本执行是原子的，即脚本执行期间redis不会执行其他命令，所有的命令都必须等待脚本执行完成后才能执行，为了防止某个脚本执行时间过长导致redis无法提供服务，redis提供了lua-time-limit参数限制脚本的最长运行时间，默认为5秒钟，当脚本运行时间超过这一限制后，redis将开始接受其他命令但不会执行，而是会返回BUSY错误，此时redis虽然可以接受任何命令，但实际执行的只有两个命令：SCRIPT KILL和SHUTDOWN NOSAVE

需要注意的是如果当前执行的脚本对redis的数据进行了修改，则SCIRPT KILL命令不会终止脚本的运行以防止脚本只执行了一部分，违背脚本的原子性要求，这时只能通过SHUTDOWN NOSAVE命令强制终止redis

Redis支持两种方式的持久化，一种是RDB方式，另一种是AOF方式，前者会根据指定的规则定时将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来

RDB方式

RDB方式的持久化是通过快照完成的，当符合一定条件时redis会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即为 快照 。redis会在以下几种情况下对数据进行快照：

根据配置规则进行自动快照

用户执行SAVE或BGSAVE命令

执行FLUSHALL命令

执行复制时

redis允许用户自定义快照条件，当符合快照条件时，redis会自动执行快照操作，进行快照的条件由两个参数构成：时间窗口M和改动的键的个数N，每当时间M内被更改的键的个数大于N时，即符合自动快照条件

redis默认会将快照文件存储在redis当前进程的工作目录的dump.rdb文件中，过程如下：

1.redis使用fork函数复制一份当前进程的副本

2.父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件

3.当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成

在执行fork的时候操作系统会使用写时复制策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时，操作系统会将该片数据复制一份保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据

redis启动后会读取RDB快照文件，将数据从硬盘载入到内存，根据数据量大小与结构和服务器性能不同，这个时间也不同，通过RDB方式实现持久化，一旦redis异常退出，就会丢失最后一次快照以后更改的所有数据，这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围，如果数据相对重要，希望将损失降到最小，则可以使用AOF方式进行持久化

当使用redis存储非临时数据时，一般需要打开AOF持久化来降低进程中止导致的数据丢失，AOF可以将redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低redis的性能，但是大部分情况下这个影响是可以接受的

AOF文件的保存位置和RDB文件的位置相同，默认文件名是appendonly.aof

AOF文件的内容就是redis客户端向redis发送的原始通信协议的内容

redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易，此时重新启动redis后会使用AOF文件来恢复数据

在复制的概念中，数据库分为两类，一类是主数据库，另一类是从数据库，主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库，而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库

在redis中使用复制功能非常容易，只需要在从数据库的配置文件中加入“slaveof 主数据库地址 端口”即可，主数据库无需进行任何配置

从数据库默认情况下是只读的，如果直接修改从数据库的数据会出现错误，可以通过设置从数据库的配置文件中slave-read-only为no以使从数据库可写，但是对从数据库的任何更改都不会同步给任何其他数据库，所以通常情况下不应该设置从数据库可写

redis详细的复制过程

当一个从数据库启动后，会向主数据库发送SYNC命令。同时主数据库接收到SYNC命令后会开始在后台保存快照，并将保存快照期间接收到的命令缓存起来，当快照完成后，redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。以上过程称为复制初始化，初始化结束后，主数据库每当收到写命令时就会将命令同步给从数据库，从而保证主从数据库的一致性。需要注意的是在同步过程中从数据库并不会阻塞，而是可以继续处理客户端发来的命令，默认情况下，从数据库会用同步前的数据对命令进行响应

在复制的过程中，快照在主数据库和从数据库都起了很大的作用，只要执行复制就会进行快照

乐观复制  redis采用了乐观复制的策略，容忍在一定时间内主从数据库的内容是不同的，但是两者的数据会最终同步，具体来说，redis在主从数据库之间复制数据的过程本身就是异步的，主数据库执行完客户端请求的命令后会立即将命令在主数据库的执行结果返回给客户端，并异步地将命令同步给从数据库，而不会等待从数据库接收到该命令后再返回给客户端，这一特性保证了启用复制后主数据库的性能不会受到影响，但另一方面也会产生一个主从数据库数据不一致的时间窗口，当主数据库执行了一条写命令后，主数据的数据已经发生的变动，然而在主数据库将该命令传送给从数据库之前，如果两个数据库之间的网络连接断开了，此时两者之间的数据就会是不一致的。从这个角度来看，主数据库是无法得知某个命令最终同步给了多少个从数据库的，不过redis提供了两个配置选项来限制只有当数据至少同步给指定数据的从数据库时，主数据库才是可写的

为了提高性能，可以通过复制功能建立一个或多个从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃重启后主数据库会自动将数据同步过来，所以无需担心数据丢失

然而当主数据库崩溃时，情况就稍显复杂了。手工通过从数据库恢复主数据库数据时，需要严格按照以下两步

1.在从数据库中使用SLAVEOF NO ONE命令将从数据库提升成主数据继续服务

2.启动之前崩溃的主数据库，然后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可将数据同步回来

当开启复制且主数据库关闭持久化功能时，一定不要使用Supervisor以及类似的进程管理工具令主数据库崩溃后自动重启，同样当主数据库所在的服务器因故关闭时，也要避免直接重新启动，这时因为当主数据库重新启动后，因为没有开启持久化功能，所以数据库中所有数据都被清空，这时从数据库依然会从主数据库中接收数据，使得所有从数据库也被清空，导致从数据库的持久化失去意义

无论哪种情况，手工维护从数据库或主数据库的重启以及数据恢复都相对麻烦，好在redis提供了一种自动化方案哨兵来实现这一过程

redis复制的原理是基于RDB快照的方式实现的，这样做有以下两个缺点：

1.当主数据库禁用RDB快照时，如果执行了复制初始化操作，redis依然会生成RDB快照，所以下次启动后主数据库会以该快照恢复数据，因为复制发生的时间不能确定，这使得恢复的数据可能是任何时间点的

2.如果硬盘性能很慢时这一过程会对性能产生影响

因此从2.8.18版本开始，redis引入了无硬盘复制选项，开启该选项时，redis在与从数据库进行复制初始化时不会将快照内容存储到硬盘上，而是直接通过网络发送给从数据库。

增量复制

当主从数据库连接断开后，从数据库会发送SYNC命令来重新进行一次完整复制操作，这样即使断开期间数据库的变化很小，也需要将数据库中的所有数据重新快照并传送一次，在正常的网络应用环境中，这种实现方式显然不太理想，redis2.8版本最重要的更新之一就是实现了主从断线重连的情况下的增量复制

增量复制是基于以下3点实现的

1.从数据库会存储主数据库的运行ID，每个redis运行实例均会拥有一个唯一的运行ID，每当实例重启后，就会自动生成一个新的运行ID

2.在复制同步阶段，主数据库每将一个命令传送给从数据库时，都会同时把该命令存放到一个积压队列中，并记录下当前积压队列中存在的命令的偏移量范围

3.同时，从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量

这三点是实现增量复制的基础，当主从连接准备就绪后，2.8版本后，从数据库不再发送SYNC命令，而是发送PSYNC命令，格式为"PSYNC 主数据库运行ID 断开之前最新的命令偏移量" 。主数据库收到PSYNC命令后，会执行以下判断来决定此次重连是否可以执行增量复制

1.首先主数据库会判断从数据库传送来的运行ID是否和自己的运行ID相同。这一步骤的意义在于确保从数据库之前确实是和自己同步的，以免从数据库拿到错误的数据

2.然后判断从数据库最后同步成功的命令偏移量是否在积压队列中，如果在则可以执行增量复制，并将积压队列中相应的命令发送给从数据库

如果此次重连不满足增量复制的条件，主数据库会进行一次全量同步

积压队列在本质上是一个固定长度的循环队列，默认情况下积压队列的大小为1MB，可以通过配置参数repl-backlog-size来调整，积压队列越大，其允许的主从数据库断线的时间就越长，根据主从数据库之间的网络状态，设置一个合理的积压队列很重要

哨兵

哨兵的作用就是监控redis系统的运行状况，它的功能包括以下两个

1.监控主数据库和从数据库是否正常运行 2.主数据库出现故障时自动将从数据库转换为主数据库

在一个一主多从的redis系统中，可以使用多个哨兵进行监控任务以保证系统足够稳健，此时哨兵不仅会同时监控主数据库和从数据库，哨兵之间也会互相监控

配置哨兵，配置文件sentinel.conf如下: sentinel monitor mymaster 127.0.0.1 6379 1其中mymaster表示要监控的主数据库的名字，可以自己定义，后两个参数表示主数据库的地址和端口号，最后的1表示最低通过票数

接下来启动sentinel进程，并将上述配置文件的路径传递给哨兵 $redis-sentinel /path/to/sentinel.conf ,配置哨兵监控一个系统时，只需要配置其监控的主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库

一个哨兵节点可以同时监控多个redis主从系统，同时多个哨兵节点也可以同时监控同一个redis主从系统，从而形成网状结构

哨兵启动后，会与要监控的主数据库建立两条连接，其中一条用来订阅该主数据库的_sentinel_:hello频道以获取其他同样监控该数据库的哨兵节点的信息，另外哨兵也需要定期向主数据库发送INFO等命令来获取主数据库本身的信息，因为客户端的连接进入订阅模式时就不能再执行其他命令了，所以这时哨兵会使用另外一条连接来发送这些命令

1.每10秒哨兵会向主数据库和从数据库发送INFO命令

2.每两秒哨兵会向主数据库和从数据库的_sentinel_:hello频道发送自己的信息

3.每一秒哨兵会向主数据库、从数据库和其他哨兵节点发送PING命令

首先，发送INFO命令使得哨兵可以获得当前数据库的相关信息（运行ID、复制信息）从而实现新节点的自动发现，前面说配置哨兵监控redis主从系统时只需要指定主数据库的信息即可，因为哨兵正是借助INFO命令来获取所有复制该主数据库的从数据库信息的。启动后，哨兵向主数据库发送INFO命令，通过解析返回结果来得知从数据库列表，而后对每个从数据库同样建立两个连接，在此之后，哨兵会每10秒定时向已知的所有主从数据库发送INFO命令来 获取信息更新并进行相应的操作，比如对新增的从数据库建立连接并加入监控列表，对主从数据库的角色变化进行信息更新

接下来哨兵向主从数据库的_sentinal_:hello频道发送信息来与同样监控该数据库的哨兵分享自己的信息，当其他哨兵收到消息后，会判断发消息的哨兵是不是新发现的哨兵，如果是则将其加入已发现的哨兵列表并创建一个到其的连接，同时哨兵会判断信息中主数据库的配置版本，如果该版本比当前记录的主数据库版本高。则更新主数据库的连接

实现了自动发现从数据库和其他哨兵节点后，哨兵要做的就是定时监控这些数据库和节点有没有停止服务，这是通过每隔一定时间向这些节点发送PING命令实现的

当超过down-after-milliseconds选项指定时间后，如果被PING的数据库仍然未进行回复，则哨兵认为其主观下线。主观下线表示从当前的哨兵进程来看，该节点已经下线，如果该节点是主数据库，则哨兵会进一步判断是否需要对其进行故障恢复：哨兵发送SENTINEL is-master-down-by-addr命令询问其他哨兵节点以了解他们是否也认为该主数据库主观下线，如果达到指定数量时，哨兵会认为其客观下线，并选举领头的哨兵节点对主从系统发起故障恢复，这个指定数量即为前文介绍的quorum参数

虽然当前哨兵节点发现了主数据库客观下线，需要故障恢复，但是故障恢复需要由领头的哨兵来完成，这样可以保证同一时间只有一个哨兵节点来执行故障恢复，选举领头哨兵的过程使用了Raft算法，过程如下：

1.发现主数据库客观下线的哨兵节点向每个哨兵节点发送命令，要求对方选自己成为领头哨兵

2.如果目标哨兵节点没有选过其他人，则会同意将A设置成领头哨兵

3.如果A发现有超过半数且超过quorum参数值得哨兵节点同意选自己成为领头哨兵，则A成功成为领头哨兵

4.当有多个哨兵节点同时参选领头哨兵，则会出现没有任何节点当选的可能，此时每个参选节点将等待一个随机事件重新发起参选请求，进行下一轮选举，直到选举成功

选举出领头哨兵后，将会开始对主数据库进行故障恢复，首先领头哨兵将从从数据库中挑选一个来充当新的主数据库

1.所有在线的从数据库中，选择优先级最高的从数据库

2.如果有多个最高优先级的从数据库，则复制的命令偏移量越大的越优先

3.如果以上条件都一样，则选择运行ID最小的从数据库

选出一个从数据库后，领头哨兵将向从数据库发送SLAVEOF NO ONE命令使其升级为主数据库。而后领头哨兵向其他从数据库发送SLAVEOF命令来使其成为新主数据库的从数据库，最后一步则是更新内部的记录，将已经停止服务的旧的主数据库更新为新的主数据库的从数据库，使得当其恢复服务时自动以从数据库的身份继续服务

redis集群 包含数个（哨兵+主从）小服务器群，每个小服务器群存储一个分片的数据

对于指定的键，可以根据特定的算法来计算其属于哪个插槽，但是如何获取某一个键由哪个节点负责？

实际上，当客户端向集群中的任意一个节点发送命令后，该节点会判断相应的键是否在当前节点中，如果键在该节点中，则会像单机实例一样正常处理该命令，如果键不在该节点中，就会返回一个MOVE重定向请求，告诉客户端这个键目前由哪个节点负责，然后客户端再将同样的请求向目标节点重新发送一次以获得结果

相比单机实例，集群的命令重定向也增加了命令的请求次数，原先只需要执行一次的命令现在有可能需要依次发向两个节点，算上往返时延，可以说请求重定向对性能还是有影响

为了解决这一问题，当发现新的重定向请求时，客户端应该在重新向正确节点发送命令的同时，缓存插槽的路由信息
