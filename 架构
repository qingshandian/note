架构

搜索系统
访问量大，降低rt -> 酒店数据结构特殊，不方便使用搜索引擎 -> 本地内存 -> 内存较大，分片存储 -> 保证高可用，每个分片15台机器，总机器数150台 -> 机器数量多，db访问竞争激烈


session复制是早期企业应用系统使用比较多的一种服务器集群Session管理机制。应用服务器开启Web容器的的Session复制功能，在集群中的几台服务器之间同步Session对象，是的每台服务器上都保存所有用户的Session信息，这样任何一台机器宕机都不会导致Session数据的丢失，而服务器使用Session时候，也只需要在本机获取即可。如图1所示。

　　这种方案简单，且从本机读取session也相当快捷，但有非常明显的缺陷：只能使用在集群规模比较小的情况下（企业应用系统，使用人数少，相对比较常见这种模式），当集群规模比较大的时候，集群服务器之间需要大量的通信进行Session的复制，占用服务器和网络的大量资源，系统负担较大。而且由于用户的session信息在每台服务器上都有备份，在大量用户访问下，可能会出现服务器内存都还不够session使用的情况。

会话保持是利用负载均衡的原地址Hash算法实现，负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器上，，也可以根据cookie信息将同一个用户的请求每次都分发到同一台服务器上，不过这时的负载均衡服务器必须工作在HTTP协议层上。这种会话保持也叫黏滞会话(Sticky Sessions)

　　在Nginx中配置的会话保持：

    upstream bakend {
        ip_hash;
        server 192.168.0.14:88;
        server 192.168.0.15:80;
    }

　　这种方案虽然保证了每个用户都能准确的拿到自己的session，而且大量用户访问也不怕，但是这种会话保持不符合系统高可用的需求。这种方案有着致命的缺陷：一旦某台服务器发生宕机，则该服务器上的所有session信息就会不存在，用户请求就会切换到其他服务器，而其他服务器因为没有其对应的session信息导致无法完成相关业务。所以这种方法基本上不会被采纳。

目前最理想的服务器集群的session管理应该是session服务器，集成了高可用、伸缩性好、对保存信息大小没有限制、性能也相对很好。这种统一管理session的方式将应用服务器分离，分为无状态的应用服务器和有状态的session服务器。


JNDI 说白了就是把资源取个名字，再根据名字来找资源。
JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。
命名服务的概念其实很好理解，在生活中也有很多的例子，最典型的就是DNS(Domain Naming Service)了。众所周知，DNS是用来对人类更便于记忆的域名和计算机更便于记忆的IP地址进行映射的。因此命名服务的核心就在于映射，讲一个值映射成另一个值。

至于目录服务呢，它其实是命名服务的一种自然扩展，两者之间的关键差别是目录服务中对象可以有属性，而命名服务中对象没有属性。举个简单的例子吧，我们手机中的电话簿就是一个典型的目录服务。它将一个电话号码映射成了拥有这个号码的人，但是人这个对象不仅仅会有姓名(尽管姓名最重要)，这也就是为什么电话簿中还可以增加这个人的家庭住址，公司，电子邮件，电话铃声等等。

关于JNDI要注意的重要一点是，它提供了应用编程接口(application programming interface，API)和服务提供者接口(service provider interface，SPI)。这一点的真正含义是，要让应用与命名服务或目录服务交互，必须有这个服务的JNDI服务提供者，这正是JNDI SPI发挥作用的地方。服务提供者基本上是一组类，这些类为各种具体的命名和目录服务实现了JNDI接口—很像JDBC驱动为各种具体的数据库系统实现了JDBC接口一样。作为一个应用开发者，我们不必操心JNDI SPI的具体实现。只需要确认要使用的某一个命名或目录服务都有服务提供者。


企业应用这么复杂，面向接口编程，那如何用一种简单的方式来配置新的实现类呢？Java 的做法是：
已经定义了 SPI (Service Provider Interface). 包括以下几点：
  接口准备好了，如：StateFactory / ObjectFactory.
  配置：先搜索 JRE 下面的某个 jndiprovider.properties 文件当作默认实现，再查找用户 classpath 根路径下 /jndi.properties. 另外还有 System.getProperties() 和在创建 InitialContext 给一个 hashtable 作为参数，这三个参数, 有优先级的关系，越是后面具体的参数优先级越高，越前面越通用型的参数优先级越低。这一点，请看 JDK ResourceManager 这个类的源码。
  实现类与初始化它们是如何自动完成的呢？这个你需要看 Context 接口里面的常量，以及拿 Sun LDAP InitialContextFactory 运行样例来看 Context 接口的常量一个样本参数值，一般我们很重要的是 InitialContextFactory 这个参数，但也有时候也有其他参数要配置，比如：pkgs, 它是说，我们给一个包名，JNDI 管理器要查找实现时用这个包名列表当成包名，类名就是 协议名 + 固定的后缀：比如： ldap://localhost:389, 它会用一个'包名前缀.协议名.协议名 + URLContextFactory' 作为类名来搜索一个类，如果它存在就把它当成实现类，如果没找到再尝试另外一个包名前缀。你可以看 com.sun.jndi.url 名，下面有例子看，比如说 ldap:// 的情况就是 找一个类 com.sun.jndi.url.ldap.ldapURLContextFactory，如果是 dns://www.163.com/xxx 就找个 com.sun.jndi.url.dns.dnsURLContextFactory。这是 URL context factory 也就是当你使用 ctx.lookup("java:xxxx/yyy") 这种带协议前缀的时候。


Runtime.getRuntime().exec()调用方式在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观


AES算法总结
AES，高级加密标准，对称算法。它的原理是：加密方和解密方保有同一个16位长的密钥，使用AES算法加解密时需要传入该密钥参数，通过Java实现AES算法提供的工具包加密后返回的是一个Base64格式的字节数组。因此为保证密文“可读性”，需要在加密后对密文进行Base64编码，解密前进行Base64解码成密文。AES算法的安全性，取决于密钥的安全性。因此一定不要在加解密的URL中传入该密钥参数，不然没有意义。一般的做法是：前后端协商好密钥，或者通过不对称加密的方式传递密钥。

MD5算法总结
MD5,是一种信息摘要算法。简单来说，就是把一段信息（明文），通过一种有损的方式压缩成定长的字符（32位密文）。因为这种压缩方式是会损失信息的，所以是无法还原出“明文”的。虽然无法从数学上破解MD5算法，但由于现在计算机具备强大的计算能力，还是可以通过“穷举法”破解该算法。如果想用该算法加密，还可以通过“加盐”的方式提高解密难度。该算法允许多传一个参数"salt",指定通过MD5加密的次数，这样是能够提高解密难度的。

Base64算法总结
Base64算法的实现原理是公开的（工具类源码中有解释），对于开发人员来说，拿到密文，很容易就能够解析成明文。因此严格来说，Base64不能称之为加密算法，仅仅是一种编码方式。它常常用于发送Http请求时对URL中参数的编码，保证不是一眼就看出来了这些参数的意义。


forward：是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。

redirect：就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取

Hessian，像 RMI 一样，使用二进制消息进行客户端和服务端的交互。但与其他二进制远程调用技术（例如 RMI）不同的是，它的二进制消息可以移植到其他非 Java 的语言中，包括 PHP、Python、C++ 和 C#。


作为开发人员，我们经常关注于构建伟大的软件来解决业务问题。数据只是软件完成工作时要处理的原材料。但是如果你问一下业务人员，数据和软件谁更重要的话，他们很可能会选择数据。数据是许多业务的生命之血。软件通常是可以替换的，但是多年积累的数据是永远不能替换的。
你是不是觉得有些奇怪，既然数据如此重要，为何在开发软件的时候却经常将其视为事后才考虑的事情？以我们前面上一章所介绍的远程服务为例，这些服务是以操作和处理为中心的，而不是信息和资源。
近几年来，以信息为中心的表述性状态转移（Representational State Transfer，REST）已成为替换传统 SOAP Web 服务的流行方案。SOAP 一般会关注行为和处理，而 REST 关注的是要处理的数据。

RPC以代码逻辑为中心
MQ以数据为中心
